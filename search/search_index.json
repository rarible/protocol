{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rarible Protocol","text":"<p>Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK.</p> <p>Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page.</p>"},{"location":"#how-to-start","title":"How to start","text":"<ul> <li>Get API-Keys to use them in API &amp; SDK</li> <li>Read Getting Started guide to learn how to Install Multichain SDK, mint your first NFT and put it on sale</li> <li>Get better understanding of Rarible Multichain Protocol with Protocol Overview Chapter</li> <li>Learn how to use SDK with our Reference</li> <li>Try using our API</li> <li>Review successful cases from our partners using Rarible Multichain Protocol in Use Cases section</li> <li>Try to look on fully functional Example Application</li> </ul> <p>If you still have questions, join open discussion on Community Resources.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<pre><code>                GNU GENERAL PUBLIC LICENSE\n                   Version 3, 29 June 2007\n</code></pre> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/  Everyone is permitted to copy and distribute verbatim copies  of this license document, but changing it is not allowed.</p> <pre><code>                        Preamble\n</code></pre> <p>The GNU General Public License is a free, copyleft license for software and other kinds of works.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works.  By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.  We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors.  You can apply it to your programs, too.</p> <p>When we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights.  Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.</p> <p>For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received.  You must make sure that they, too, receive or can get the source code.  And you must show them these terms so they know their rights.</p> <p>Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.</p> <p>For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software.  For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.</p> <p>Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so.  This is fundamentally incompatible with the aim of protecting users' freedom to change the software.  The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable.  Therefore, we have designed this version of the GPL to prohibit the practice for those products.  If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.</p> <p>Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary.  To prevent this, the GPL assures that patents cannot be used to render the program non-free.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p> <pre><code>                   TERMS AND CONDITIONS\n</code></pre> <ol> <li>Definitions.</li> </ol> <p>\"This License\" refers to version 3 of the GNU General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License.  Each licensee is addressed as \"you\".  \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy.  The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy.  Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies.  Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License.  If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p> <ol> <li>Source Code.</li> </ol> <p>The \"source code\" for a work means the preferred form of the work for making modifications to it.  \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form.  A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities.  However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work.  For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p> <ol> <li>Basic Permissions.</li> </ol> <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met.  This License explicitly affirms your unlimited permission to run the unmodified Program.  The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work.  This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force.  You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright.  Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below.  Sublicensing is not allowed; section 10 makes it unnecessary.</p> <ol> <li>Protecting Users' Legal Rights From Anti-Circumvention Law.</li> </ol> <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p> <ol> <li>Conveying Verbatim Copies.</li> </ol> <p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p> <ol> <li>Conveying Modified Source Versions.</li> </ol> <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <pre><code>a) The work must carry prominent notices stating that you modified\nit, and giving a relevant date.\n\nb) The work must carry prominent notices stating that it is\nreleased under this License and any conditions added under section\n7.  This requirement modifies the requirement in section 4 to\n\"keep intact all notices\".\n\nc) You must license the entire work, as a whole, under this\nLicense to anyone who comes into possession of a copy.  This\nLicense will therefore apply, along with any applicable section 7\nadditional terms, to the whole of the work, and all its parts,\nregardless of how they are packaged.  This License gives no\npermission to license the work in any other way, but it does not\ninvalidate such permission if you have separately received it.\n\nd) If the work has interactive user interfaces, each must display\nAppropriate Legal Notices; however, if the Program has interactive\ninterfaces that do not display Appropriate Legal Notices, your\nwork need not make them do so.\n</code></pre> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit.  Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p> <ol> <li>Conveying Non-Source Forms.</li> </ol> <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <pre><code>a) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by the\nCorresponding Source fixed on a durable physical medium\ncustomarily used for software interchange.\n\nb) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by a\nwritten offer, valid for at least three years and valid for as\nlong as you offer spare parts or customer support for that product\nmodel, to give anyone who possesses the object code either (1) a\ncopy of the Corresponding Source for all the software in the\nproduct that is covered by this License, on a durable physical\nmedium customarily used for software interchange, for a price no\nmore than your reasonable cost of physically performing this\nconveying of source, or (2) access to copy the\nCorresponding Source from a network server at no charge.\n\nc) Convey individual copies of the object code with a copy of the\nwritten offer to provide the Corresponding Source.  This\nalternative is allowed only occasionally and noncommercially, and\nonly if you received the object code with such an offer, in accord\nwith subsection 6b.\n\nd) Convey the object code by offering access from a designated\nplace (gratis or for a charge), and offer equivalent access to the\nCorresponding Source in the same way through the same place at no\nfurther charge.  You need not require recipients to copy the\nCorresponding Source along with the object code.  If the place to\ncopy the object code is a network server, the Corresponding Source\nmay be on a different server (operated by you or a third party)\nthat supports equivalent copying facilities, provided you maintain\nclear directions next to the object code saying where to find the\nCorresponding Source.  Regardless of what server hosts the\nCorresponding Source, you remain obligated to ensure that it is\navailable for as long as needed to satisfy these requirements.\n\ne) Convey the object code using peer-to-peer transmission, provided\nyou inform other peers where the object code and Corresponding\nSource of the work are being offered to the general public at no\ncharge under subsection 6d.\n</code></pre> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling.  In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage.  For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product.  A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source.  The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information.  But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed.  Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p> <ol> <li>Additional Terms.</li> </ol> <p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law.  If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it.  (Additional permissions may be written to require their own removal in certain cases when you modify the work.)  You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <pre><code>a) Disclaiming warranty or limiting liability differently from the\nterms of sections 15 and 16 of this License; or\n\nb) Requiring preservation of specified reasonable legal notices or\nauthor attributions in that material or in the Appropriate Legal\nNotices displayed by works containing it; or\n\nc) Prohibiting misrepresentation of the origin of that material, or\nrequiring that modified versions of such material be marked in\nreasonable ways as different from the original version; or\n\nd) Limiting the use for publicity purposes of names of licensors or\nauthors of the material; or\n\ne) Declining to grant rights under trademark law for use of some\ntrade names, trademarks, or service marks; or\n\nf) Requiring indemnification of licensors and authors of that\nmaterial by anyone who conveys the material (or modified versions of\nit) with contractual assumptions of liability to the recipient, for\nany liability that these contractual assumptions directly impose on\nthose licensors and authors.\n</code></pre> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10.  If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term.  If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p> <ol> <li>Termination.</li> </ol> <p>You may not propagate or modify a covered work except as expressly provided under this License.  Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License.  If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p> <ol> <li>Acceptance Not Required for Having Copies.</li> </ol> <p>You are not required to accept this License in order to receive or run a copy of the Program.  Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance.  However, nothing other than this License grants you permission to propagate or modify any covered work.  These actions infringe copyright if you do not accept this License.  Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p> <ol> <li>Automatic Licensing of Downstream Recipients.</li> </ol> <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License.  You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations.  If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License.  For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p> <ol> <li>Patents.</li> </ol> <p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based.  The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version.  For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement).  To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients.  \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License.  You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p> <ol> <li>No Surrender of Others' Freedom.</li> </ol> <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all.  For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p> <ol> <li>Use with the GNU Affero General Public License.</li> </ol> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work.  The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.</p> <ol> <li>Revised Versions of this License.</li> </ol> <p>The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number.  If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions.  However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p> <ol> <li>Disclaimer of Warranty.</li> </ol> <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> <ol> <li>Limitation of Liability.</li> </ol> <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p> <ol> <li>Interpretation of Sections 15 and 16.</li> </ol> <p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <pre><code>                 END OF TERMS AND CONDITIONS\n\n        How to Apply These Terms to Your New Programs\n</code></pre> <p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program.  It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>&lt;one line to give the program's name and a brief idea of what it does.&gt;\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:</p> <pre><code>&lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n</code></pre> <p>The hypothetical commands <code>show w' and</code>show c' should show the appropriate parts of the General Public License.  Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\".</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/.</p> <p>The GNU General Public License does not permit incorporating your program into proprietary programs.  If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library.  If this is what you want to do, use the GNU Lesser General Public License instead of this License.  But first, please read https://www.gnu.org/licenses/why-not-lgpl.html.</p>"},{"location":"MIT-LICENSE/","title":"MIT LICENSE","text":"<p>Copyright (c) 2021, Rarible DAO</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#documentation-and-base-url","title":"Documentation and base URL","text":"<p>ATTENTION: Flow blockchain is temporary out of support - no data is provided on API for Flow blockchain, direct API calls with FLOW blockchain specified are ruturning ERROR 400 \"Flow is not supported\"</p> <p>Use these base URLs to access our API on different networks.</p> <p><code>api.rarible.org</code> or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs.</p> Documentation Base URL Environments multichain-api.rarible.org For all environments api.rarible.org/v0.1/doc https://api.rarible.org/v0.1 Production (Mainnet) testnet-api.rarible.org/v0.1/doc https://testnet-api.rarible.org/v0.1 Development (Rinkeby, Mumbai, Ithaca) <p>On the multichain-api.rarible.org page, you can make API requests using the TryIt function. To start using:</p> <ol> <li>Change environments on the top left side</li> <li>Choose API method</li> <li>Click Try it button:<ol> <li>Configure the request parameters if required</li> <li>Click Send button</li> </ol> </li> </ol> <p>Also see additional information and API usage examples on the Search Capabilities page.</p>"},{"location":"api-reference/#environments","title":"Environments","text":"<p>The API interacts with different blockchain networks for different environments.</p> <p>Production:</p> <ul> <li>Ethereum: mainnet</li> <li>Tezos: mainnet</li> <li>Flow: mainnet</li> <li>Polygon: mainnet</li> <li>Solana: mainnet-beta</li> <li>Immutablex: mainnet</li> </ul> <p>Testnet:</p> <ul> <li>Ethereum: rinkeby</li> <li>Tezos: ithaca</li> <li>Flow: devnet</li> <li>Polygon: mumbai</li> <li>Solana: devnet</li> <li>Immutablex: ropsten</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>See Discussion QA section on our GitHub repo, Discord, and documentation for more answers.</p> <p>If you haven't found an answer to your question, you can create a new discussion here. </p> <p>WIP. It's the first FAQ version.</p>"},{"location":"faq/#do-i-need-tokenid-to-lazy-minting-nft-through-sdk","title":"Do I need tokenId to lazy minting NFT through SDK?","text":"<p>Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint.</p>"},{"location":"faq/#how-to-connect-metamask-with-sdk","title":"How to connect Metamask with SDK?","text":"<p>Something like that:</p> <pre><code>new EthereumWallet(new Web3Ethereum({ web3: web31 }))\n</code></pre> <p>Now you can pass your wallet to the create SDK factory.</p> <p>See Rarible Protocol SDK for more information about using SDK.</p>"},{"location":"faq/#why-the-price-in-the-sell-order-cant-be-updated-to-a-higher-value","title":"Why the price in the sell order can't be updated to a higher value?","text":"<p>That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract.</p> <p>So, to make the price higher, you should cancel the order and sign a new message.</p>"},{"location":"faq/#what-does-the-union-service-repo-do","title":"What does the union-service repo do?","text":"<p>Multichain service also known as <code>union service</code> is a layer that connects different Blockchain APIs. It sits on top of all of them.</p>"},{"location":"faq/#what-kind-of-fee-model-does-the-protocol-use","title":"What kind of fee model does the protocol use?","text":"<p>See Smart contracts for Rarible protocol repo on GitHub for more information about fees.</p> <p>Also, you can find more information about fees in Rarible Protocol Ethereum docs.</p>"},{"location":"faq/#what-is-deploy-in-the-sdk-used-for","title":"What is \"deploy\" in the SDK used for?","text":"<p>It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.</p>"},{"location":"features/","title":"Rarible Protocol Features List","text":"<p>ATTENTION: Flow blockchain is temporary out of support - no data is provided on API for Flow blockchain, direct API calls with FLOW blockchain specified are ruturning ERROR 400 \"Flow is not supported\"</p> Multichain Protocol supported features Description NFT API (Items/Collections/Ownership/Activity/Users) ETH POL TEZ FLOW SOL IMX Metadata ETH POL TEZ FLOW SOL IMX NFT Liquidity Get Orders ETH (Rarible, SeaPort, LooksRare, x2y2, Rarible Community Marketplaces) POL (Rarible) TEZ (Rarible, Objkt, HEN) FLOW (Rarible, NFT Storefront) SOLANA IMX (on-chain orderbook) Rarible SDK Mint NFTs ETH POL TEZ FLOW SOL Lazy Mint NFTs ETH POL Execute order ETH POL TEZ FLOW SOL IMX Bulk orders execute ETH POL TEZ FLOW SOL IMX Additional NFT collections ETH CryptoPunks FLOW MotoGP, Evolution, Mugen ARt, Vault by CNN, Starly, Matrix World Voucher, Matrix World Flow Fest, VersusArt, DisruptArt, OneFootball, Jambb, Fanfare, Chainmonsters, Barter Yard Club, ClosedSrc  SOL Degenerate Ape Academy"},{"location":"getting-started/community/","title":"Community and resources","text":""},{"location":"getting-started/community/#dao","title":"DAO","text":"<p>If you're a builder, or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders.</p> <ul> <li>Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol.</li> <li>GitHub is where everything lives. Since we are open-source, many resources and help from other builders are available there.</li> <li>OpenAPI is where we document the current API capabilities.</li> </ul>"},{"location":"getting-started/community/#resources","title":"Resources","text":"<ul> <li>Rarible YouTube</li> <li>Rarible Protocol Twitter</li> <li>Rarible Hackathon Docs HackMD by Isaac for Ethereum network.</li> </ul>"},{"location":"getting-started/community/#submitting","title":"Submitting","text":"<p>You are welcome to suggest features and report bugs found! You can do it here:</p> <ul> <li>Submit an issue</li> <li>Submit a question or suggestion</li> </ul>"},{"location":"getting-started/community/#audits","title":"Audits","text":"<p>Rarible Protocol is audited. Check this report by ChainSecurity.com.</p>"},{"location":"getting-started/community/#license","title":"License","text":"<p>Rarible Protocol is available under GPL v3.</p> <p>SDK and OpenAPI (with generated clients) are available under MIT.</p>"},{"location":"getting-started/fetch-nft-data/","title":"How to fetch NFT data using Rarible Multichain API","text":"<p>In the previous article, we showed you how to find NFTs you\u2019re interested in, by using different searching parameters (such as collection, address, or user name) on a marketplace\u2019s website. In general, that\u2019s a very simple process\u2026unless you want to fetch details from many different NFTs.</p> <p>In this article, we\u2019ll learn how to get information on NFTs-related activities, straight from the source. In other words, we will cover how you can implement the same functionality you see on the Rarible Marketplace, using the Rarible Multichain Protocol.</p> <p>The Rarible Multichain Protocol is an API developed by the Rarible team that allows you to fetch activity information of different NFT projects \u2014 NFTs details, orders, owners, bids, etc. Since we will be using an API to get information, you\u2019ll be able to fully automate the search process and do it in a structured and repetitive manner.</p>"},{"location":"getting-started/fetch-nft-data/#api-overview","title":"API Overview","text":"<p>The Rarible Multichain Protocol organizes search capabilities in a set of controllers. Each controller provides a fine-grained API to retrieve certain pieces of information about the NFT, or any of its attributes.</p> <p>The API comprises the following controllers:</p> <ul> <li>Signature Controller \u2014 responsible for verifying signatures of messages</li> <li>Currency Controller \u2014 it allows us to get a USDC rate for a given token</li> <li>Item Controller \u2014 it lets us check all sorts of item-related information, like item details, owner, collection, etc.</li> <li>Ownership Controller \u2014 returns ownership details</li> <li>Order Controller \u2014 responsible for fetching order information, like sell order, order by id, orders by the maker</li> <li>Auction Controller \u2014 auctions related information (auctions are not yet supported on the API)</li> <li>Activity Controller \u2014 activity information, such as token transfer, minting, burning, aggregated by users, items, collections</li> <li>Collection Controller \u2014 collections-related information</li> </ul> <p>As you can see, there is a controller for every imaginable parameter, so getting the desired information won\u2019t be a problem. The hard part is to easily navigate through the information we get from them, and make our logic as simple as possible.</p>"},{"location":"getting-started/fetch-nft-data/#search-for-a-collection","title":"Search for a collection","text":"<p>Let\u2019s recreate a simple scenario, just to put this into context.</p> <p>Let\u2019s say that the only information we have about a collection is its ID, aka collection address. It\u2019s the moonbird collection, and we want to know everything about it. We access the Rarible Multichain API docs and start building.</p> <p>Since the only information we have is the collection address, the first endpoint we\u2019ll use is <code>getCollectionById</code>. To be precise, it\u2019s this one.</p> <p></p> <p>As we can see, we have to pass the collection address as a parameter, along with the blockchain name in which the contract resides. To get the contract address of a collection, we access the Rarible website and find the collection by name. There, we\u2019re able to get the contract address, which appears right under the collection\u2019s name.</p> <p></p> <p>We\u2019re now ready to make the first request.</p> <pre><code>curl https://api.rarible.org/v0.1/collections/ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\n</code></pre> <p>We\u2019re then able to retrieve the following information:</p> Collections response <pre><code>{\n  \"id\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\",\n  \"blockchain\": \"ETHEREUM\",\n  \"type\": \"ERC721\",\n  \"name\": \"Moonbirds\",\n  \"symbol\": \"MOONBIRD\",\n  \"owner\": \"ETHEREUM:0x83895f7508926741cd2147c4aac65c30a851cc30\",\n  \"features\": [\n    \"APPROVE_FOR_ALL\"\n  ],\n  \"minters\": [],\n  \"meta\": {\n    \"name\": \"Moonbirds\",\n    \"description\": \"A collection of 10,000 utility-enabled PFPs that feature a richly diverse and unique pool of rarity-powered traits. What's more, each Moonbird unlocks private club membership and additional benefits the longer you hold them. We call it nesting \u2013 because, obviously.\",\n    \"content\": [\n      {\n        \"@type\": \"IMAGE\",\n        \"url\": \"https://lh3.googleusercontent.com/sn5iLHUcNuUO98w_9Z7cat32hiqvVkPYr6tzHUacESg4PePh9M3jySvpttyWWXHD2e8M4PNQqgorU9sUvpX-FHQHXFBiCpKjloC2nA=s120\",\n        \"representation\": \"ORIGINAL\"\n      }\n    ],\n    \"externalLink\": \"https://moonbirds.xyz\",\n    \"sellerFeeBasisPoints\": 250,\n    \"feeRecipient\": \"ETHEREUM:0xc8a5592031f93debea5d9e67a396944ee01bb2ca\"\n  },\n  \"bestBidOrder\": {\n    \"id\": \"ETHEREUM:0x299628bf0f59e046b3edd259bbf66c4e11dc5b02dcc13a65cf86cf7d02ce9b34\",\n    \"fill\": \"0\",\n    \"platform\": \"RARIBLE\",\n    \"status\": \"ACTIVE\",\n    \"makeStock\": \"11.1\",\n    \"cancelled\": false,\n    \"createdAt\": \"2022-06-20T14:46:47.960Z\",\n    \"lastUpdatedAt\": \"2022-06-22T04:11:45Z\",\n    \"dbUpdatedAt\": \"2022-06-22T04:12:09.894Z\",\n    \"takePrice\": \"11.1\",\n    \"takePriceUsd\": \"12042.01013500119849\",\n    \"maker\": \"ETHEREUM:0x0272aafe06eff7a72420835b1e5a60ba118cb2fc\",\n    \"make\": {\n      \"type\": {\n        \"@type\": \"ERC20\",\n        \"contract\": \"ETHEREUM:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n      },\n      \"value\": \"11.1\"\n    },\n    \"take\": {\n      \"type\": {\n        \"@type\": \"COLLECTION\",\n        \"contract\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\"\n      },\n      \"value\": \"1\"\n    },\n    \"salt\": \"0x270199a227cc7cddb27513ab58ccbb803e6c7b9f4c677d9023462af182b8b5df\",\n    \"signature\": \"0x2a3804723ded47b71f7ca3acf64c0bb3f1f507603ca67dab3c0ba123915aedf251be329e0e5fe5157404a16099e1603cdd5b38d55af6dfa7fd1a894289105b0c01\",\n    \"pending\": [],\n    \"data\": {\n      \"@type\": \"ETH_RARIBLE_V2\",\n      \"payouts\": [],\n      \"originFees\": [\n        {\n          \"account\": \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\",\n          \"value\": 100\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Let\u2019s examine the received data. With the above response, we can see which blockchain the collection was minted on, what type of NFT it represents (ERC721 vs ERC1155), who is the owner of the collection (in other words, which address deployed the contract) and metadata information (which tells you the collection name, description, etc.).</p> <p>Moving on, we have the <code>bestBidOrder</code> parameter, which looks like this:</p> bestBidOrder <pre><code>  \"bestBidOrder\": {\n    \"id\": \"ETHEREUM:0x299628bf0f59e046b3edd259bbf66c4e11dc5b02dcc13a65cf86cf7d02ce9b34\",\n    \"fill\": \"0\",\n    \"platform\": \"RARIBLE\",\n    \"status\": \"ACTIVE\",\n    \"makeStock\": \"11.1\",\n    \"cancelled\": false,\n    \"createdAt\": \"2022-06-20T14:46:47.960Z\",\n    \"lastUpdatedAt\": \"2022-06-22T04:11:45Z\",\n    \"dbUpdatedAt\": \"2022-06-22T04:12:09.894Z\",\n    \"takePrice\": \"11.1\",\n    \"takePriceUsd\": \"12042.01013500119849\",\n    \"maker\": \"ETHEREUM:0x0272aafe06eff7a72420835b1e5a60ba118cb2fc\",\n    \"make\": {\n      \"type\": {\n        \"@type\": \"ERC20\",\n        \"contract\": \"ETHEREUM:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n      },\n      \"value\": \"11.1\"\n    },\n    \"take\": {\n      \"type\": {\n        \"@type\": \"COLLECTION\",\n        \"contract\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\"\n      },\n      \"value\": \"1\"\n    },\n    \"salt\": \"0x270199a227cc7cddb27513ab58ccbb803e6c7b9f4c677d9023462af182b8b5df\",\n    \"signature\": \"0x2a3804723ded47b71f7ca3acf64c0bb3f1f507603ca67dab3c0ba123915aedf251be329e0e5fe5157404a16099e1603cdd5b38d55af6dfa7fd1a894289105b0c01\",\n    \"pending\": [],\n    \"data\": {\n      \"@type\": \"ETH_RARIBLE_V2\",\n      \"payouts\": [],\n      \"originFees\": [\n        {\n          \"account\": \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\",\n          \"value\": 100\n        }\n      ]\n    }\n  }\n</code></pre> <p>Here, we can see the <code>bestBidOrder</code> information related to the collection, which shows the details of an offer someone made to an NFT in this collection. We can also see which platform the offer was created on, if it\u2019s active or not, the value associated with this offer, etc.</p> <p>In addition to the <code>maker</code> and <code>taker</code> parameters, we\u2019re able to see what type of assets are offered. In this example, the maker offers 11.1 ERC20 tokens from a given address. You can check which token was offered, by typing its address on etherscan. In this case, the offer was made in DAI tokens. You can also check what the offer maker wants in return, in the <code>take</code> parameter. It\u2019s a collection type token from a given contract. In our case, the moonbird collection token.</p>"},{"location":"getting-started/fetch-nft-data/#get-all-nfts-in-a-collection","title":"Get all NFTs in a collection","text":"<p>Moving on, since NFTs are created inside a collection, the next logical step will be to find all the NFTs in that collection. We will do it by using an item controller and the getItemsByCollection endpoint.</p> <pre><code>curl https://api.rarible.org/v0.1/items/byCollection?collection=ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\n</code></pre> <p>An example of a received response can be seen below.</p> <pre><code>{\n    \"total\": 50,\n    \"continuation\": \"1655744480000_0x23581767a106ae21c074b2276d25e5c3e136a68b:8902\",\n    \"items\": [{\"...\"}]\n}\n</code></pre> <p>Since the moonbirds collection contains 10.000 NFTs, we won\u2019t be able to fetch all of them with a single request. With a single request we\u2019re able to get up to 50 items and the continuation string, which allows us to iterate over the next set of items. We just need to make a new request with added continuation string as a query parameter, like this:</p> <pre><code>curl https://api.rarible.org/v0.1/items/byCollection?collection=ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b&amp;continuation=1655744480000_0x23581767a106ae21c074b2276d25e5c3e136a68b:8902\n</code></pre> <p>The continuation string will be present until we fetch all the NFTs. This is an example of how the JSON <code>items</code> looks. As you can see in the response below, you can find all the information related to the NFT.</p> items <pre><code>{\n        \"id\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1474\",\n        \"blockchain\": \"ETHEREUM\",\n        \"collection\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\",\n        \"contract\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\",\n        \"tokenId\": \"1474\",\n        \"creators\": [{\n            \"account\": \"ETHEREUM:0x1bcb5e317671cf1931a2095cbc2ff1a1378a2fd4\",\n            \"value\": 10000\n        }],\n        \"owners\": [],\n        \"royalties\": [{\n            \"account\": \"ETHEREUM:0xc8a5592031f93debea5d9e67a396944ee01bb2ca\",\n            \"value\": 500\n        }],\n        \"lazySupply\": \"0\",\n        \"pending\": [],\n        \"mintedAt\": \"2022-04-16T15:47:56Z\",\n        \"lastUpdatedAt\": \"2022-04-29T08:28:35Z\",\n        \"supply\": \"1\",\n        \"meta\": {\n            \"name\": \"#1474\",\n            \"attributes\": [{\n                \"key\": \"Eyes\",\n                \"value\": \"Open\"\n            }, {\n                \"key\": \"Headwear\",\n                \"value\": \"Halo\"\n            }, {\n                \"key\": \"Body\",\n                \"value\": \"Crescent\"\n            }, {\n                \"key\": \"Feathers\",\n                \"value\": \"Purple\"\n            }, {\n                \"key\": \"Background\",\n                \"value\": \"Yellow\"\n            }, {\n                \"key\": \"Beak\",\n                \"value\": \"Long\"\n            }],\n            \"content\": [{\n                \"@type\": \"IMAGE\",\n                \"url\": \"https://live---metadata-5covpqijaa-uc.a.run.app/images/1474\",\n                \"representation\": \"ORIGINAL\",\n                \"mimeType\": \"image/png\",\n                \"width\": 1008,\n                \"height\": 1008\n            }],\n            \"restrictions\": []\n        },\n        \"deleted\": false,\n        \"auctions\": [],\n        \"totalStock\": \"0\",\n        \"sellers\": 0,\n        \"lastSale\": {\n            \"date\": \"2022-04-26T00:58:00Z\",\n            \"seller\": \"ETHEREUM:0xf16e9d68e71fb936cf7d35c4c2b25e1f7d13e70a\",\n            \"buyer\": \"ETHEREUM:0x9e7e99d56f8cadb8fde5956bc1c9b9ab1550ed2f\",\n            \"value\": \"1\",\n            \"currency\": {\n                \"@type\": \"ETH\",\n                \"blockchain\": \"ETHEREUM\"\n            },\n            \"price\": \"27\"\n        }\n    }\n</code></pre> <p>Now the fun begins! \ud83e\udd73 Since you\u2019re able to fetch all the NFT details, you can use this information to gather orders assigned to it.</p>"},{"location":"getting-started/fetch-nft-data/#get-information-on-nft-activities","title":"Get information on NFT activities","text":"<p>So far, we know how to fetch collections and NFTs information. Now, we\u2019re gonna learn how we can do the same with NFT activities. We\u2019re gonna elevate an activity controller for that.</p> <p>To start, let\u2019s quickly remember what the activity is. An activity represents any action taken on the blockchain. Examples of activities include: minting, burning, making a bid, buying, etc. Since Rarible has its own custom indexer (for people interested in this topic, we\u2019ll cover it in other articles), it stores all of this data in a database, which you\u2019re free to explore and use.</p> <p>Activities can be fetched by a number of different parameters. You can get activities by user, item, or collection. The structure is similar to the one used in previous requests.</p> <p>Let\u2019s fetch an activity of type <code>MINT</code> by item, with the following request:</p> <pre><code>curl https://api.rarible.org/v0.1/activities/byItem?itemId=ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1746&amp;type=MINT\n</code></pre> <p>Which provides us with this information:</p> getActivitiesByItem response <pre><code>{\n  \"cursor\": \"1650124806000_14597286_368_594483237825392469\",\n  \"activities\": [\n    {\n      \"@type\": \"MINT\",\n      \"id\": \"ETHEREUM:625ae855037fb52f6c436181\",\n      \"date\": \"2022-04-16T16:00:06Z\",\n      \"lastUpdatedAt\": \"2022-04-16T16:01:25.414Z\",\n      \"cursor\": \"1650124806000_14597286_368_594483237825392469\",\n      \"reverted\": false,\n      \"owner\": \"ETHEREUM:0xef51c6b7eff0d16038743bf924879d295a4b971f\",\n      \"contract\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\",\n      \"tokenId\": \"1746\",\n      \"itemId\": \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1746\",\n      \"value\": \"1\",\n      \"transactionHash\": \"0xda308c38b554ad01310444760fac3dba0ff614d08985a0a3b76ce1230c29c853\",\n      \"blockchainInfo\": {\n        \"transactionHash\": \"0xda308c38b554ad01310444760fac3dba0ff614d08985a0a3b76ce1230c29c853\",\n        \"blockHash\": \"0xe2190936e3d748e26ab6d3a0351d053e2c7219eab18d4420a24b8c39d2b8e768\",\n        \"blockNumber\": 14597286,\n        \"logIndex\": 368\n      }\n    }\n  ]\n}\n</code></pre> <p>You can now see all available activity info, such as type, date, reverted (it tells you if the transaction was indexed but not reflected in the blockchain), etc.</p>"},{"location":"getting-started/fetch-nft-data/#summary","title":"Summary","text":"<p>In this article, we gave you an overview of the Rarible Multichain Protocol API, which allows you to fetch much different information about NFT collections, activities, and more. We mainly focused on the most used controllers, i.e., items, and collection controllers. There are many more, though!</p> <p>The Rarible Multichain API can be used to build your own custom apps. It\u2019s free, and it allows you to include tons of functionalities out of the box. You can list NFTs, activities, and marketplaces, all without a single line of solidity code.</p>"},{"location":"getting-started/flow-blockchain-tutorial/","title":"How to create NFTs on Flow Blockchain using Rarible Protocol","text":"<p>If you\u2019re looking for alternatives to the Ethereum blockchain, there are plenty of different options. One of them is Flow, a blockchain developed by the CryptoKitties and Dapper creators. It was built with scalability in mind and was tailored for intense blockchain usage.</p> <p>In this article, we will walk through Flow features in more detail, talk about what makes it unique, and explore the creation of NFTs on the Flow blockchain using Rarible Protocol.</p>"},{"location":"getting-started/flow-blockchain-tutorial/#what-is-the-flow-blockchain","title":"What is the Flow Blockchain","text":"<p>Speaking in marketing terms, Flow is \u201ca fast, decentralized, and developer-friendly blockchain, designed as the foundation for a new generation of games, apps, and the digital assets that power them.\u201d To be honest, after researching it for a while, it does appear so. Let\u2019s break it down a little, and highlight all the pros.</p> <p>There are 4 main reasons why Flow is considered unique, often referenced as the \u201cFour Pillars\u201d, which are:</p> <ul> <li>Multirole architecture</li> <li>Resource-oriented programming</li> <li>Developer ergonomics</li> <li>Consumer onboarding</li> </ul> <p>We\u2019ll now break down each pillar, so you can get a better understanding of Flow blockchain.</p> <p>Multirole architecture</p> <p>On Flow, instead of every node managing everything around transactions processes (like storing the entire state), the dev team had them split into pipelines. What that means in practice is that the work is split into a few different parts, which allows the blockchain to scale dramatically.</p> <p>Resource-oriented programming</p> <p>What resources mean, in this context, is a new way of representing asset ownership. Thanks to Cadence (which is the native language of Flow\u2019s smart contracts) \u2014 \u201cdevelopers can create uniquely durable digital artifacts where ownership is tracked by the language itself, enabling a powerful new category of applications\u201d (source).</p> <p>Developer ergonomics</p> <p>By developer ergonomics, Flow means: developer-friendly smart contracts creation. Additionally, smart contracts on Flow are upgradable. On Flow, you are allowed to deploy a contract to mainnet in its \u201cbeta state\u201d, allowing the authors to incrementally update the code. Users are alerted about the status of the contract and are able to choose if they want to trust it now, or only after it\u2019s finalized.</p> <p>Consumer onboarding</p> <p>Flow puts a lot of effort on consumers. For example, ETH transactions contain very little information about the transaction itself. You just trust it, which is not ideal. On Flow, you get detailed transaction info and guarantees about what transactions can and cannot do.</p> <p>In my honest opinion, Flow does sound pretty neat. Now it\u2019s time to dive into how we can take advantage of it with Rarible Protocol.</p>"},{"location":"getting-started/flow-blockchain-tutorial/#flow-contracts-on-rarible-protocol","title":"Flow contracts on Rarible Protocol","text":"<p>As mentioned in the introduction, I will also provide the contracts Rarible Protocol distribute on Flow. There are four of them at the time of writing.</p> <ul> <li>RaribleFee: fee manager that holds the rates and addresses fees.</li> <li>LicensedNFT: contract interface adds royalties to NFT. You can implement this LicensedNFT on your contract (along with NFT), and your royalties will be distributed when trading on Rarible.</li> <li>RaribleNFT: the Rarible NFT contract that implements the Flow NFT standard is equivalent to ERC-721 or ERC-1155 on Ethereum.</li> <li>RaribleOrder: marketplace contract is the wrapper for the standard NFTStorefront, handling market orders.</li> </ul> <p>Smart Contracts Addresses</p> <p>Another important thing is the address of the Smart Contract that we want to use. Currently, Rarible has 4 contracts deployed, you can see them below. If you want to copy or read them, you can find all the information here.</p> <p></p> <p>We need those addresses because, in the Multichain SDK (which used to be called Union SDK), we\u2019re referencing entities like collection ID, token ID by Union Addresses, which consists of blockchain name and address after colon, like this:</p> <p>FLOW:A.ebf4ae01d1284af8.RaribleNFT</p>"},{"location":"getting-started/flow-blockchain-tutorial/#how-can-you-create-nfts-on-flow-using-the-multichain-sdk","title":"How can you create NFTs on Flow using the Multichain SDK?","text":"<p>You can follow the project template that we\u2019ve created.</p> <p>The hardest part about using the Multichain SDK is setting it up, but we\u2019ve already done that for you on the GitHub template. Now, let's walk you through the Flow-specific aspects of the process.</p> <p>Which wallet should we use for Flow?</p> <p>The first important question is, which wallet can you use for Flow? Unfortunately, you can\u2019t access it from Metamask. According to official Flow suggestions, there are two options:</p> <ul> <li>Blocto</li> <li>Ledger</li> </ul> <p>In this example, you'll be using Blocto (which is also referenced as FCL). Create a new account, and let\u2019s get started.</p>"},{"location":"getting-started/flow-blockchain-tutorial/#coding-part","title":"Coding Part","text":"<p>Finally! It\u2019s time for the coding part. \ud83e\udd73 We will make this process as easy as possible.</p> <p>1. Choose FCL as the desired wallet in <code>\\_app.tsx</code></p> <p></p> <p>When it comes to working with the Multichain SDK, there are two things that have to be right in order for the rest to work:</p> <ul> <li>Network environment</li> <li>Multichain address</li> </ul> <p>A network environment is needed for sending and signing transactions. You can treat it just like a login functionality.</p> <p>Multichain addresses, on the other hand, are needed because we\u2019re interacting with a few blockchains using one code base. So the code needs to know which blockchain (first part of the Multichain Address) and which entity (second part of the Multichain Address) we want to interact with. Values on \u201cdesired wallets\u201d will translate to buttons on the frontend (you can style them on an sdk-wallet-connector file using the Options function), which allows users to connect with chosen blockchains.</p> <p>2. Prepare Mint</p> <p></p> <p>Get information about the way you can mint a token. Information such as:</p> <ul> <li>Is lazy minting supported?</li> <li>Is multiple minting supported?</li> <li>Is the provided collection address valid?</li> </ul> <p>Remember that you can always check what\u2019s inside a response just by consoling it out. At the end of the function, we\u2019re storing the values which we\u2019re interested in, within useState hooks.</p> <p>3. Minting</p> <p></p> <p>In this step, we\u2019re submitting the response that we got in step #2. The best way to do it is to store it in the useState hook \ud83e\ude9d. In order to successfully mint an NFT, we also need URI, lazymint, and supply. One more thing I wanna cover in greater detail is URI.</p> <p>First things first, in order to successfully display an image on Rarible, the URI has to be in the following format:</p> <p>ipfs://ipfs/{hash}</p> <p>e.g. <code>ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp</code></p> <p>The second thing is that the URI should point to a metadata object like the one shown below.</p> <p></p> <p>If you want to check out what\u2019s under your URI on IPFS, you have to merge https://rarible.mypinata.cloud/ipfs/ with your hash. That\u2019s it! \ud83d\ude0e</p>"},{"location":"getting-started/flow-blockchain-tutorial/#summary","title":"Summary","text":"<p>In this article, we\u2019ve walked through the process of creating NFTs with Multichain SDK, talked about how the Flow blockchain works and what makes it unique, and covered what is the proper way to store the URI.</p>"},{"location":"getting-started/glossary/","title":"Glossary","text":"<p>This document contains a glossary with an alphabetical list, definitions, and terms related to API.</p> <p>A  |  B  |  C  |  E  |  I  |  F  |  L  |  M  |  N  |  O  |  P  |  R  |  S  |  T</p>"},{"location":"getting-started/glossary/#a","title":"A","text":"<p>API</p> <p>Application Programming Interface enables different systems to interact with each other programmatically.</p> <p>Activity</p> <p>Event history with orders or NFT tokens.</p> <p>Asset Type</p> <p>Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.).</p> <p>Asset Class</p> <p>Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.).</p>"},{"location":"getting-started/glossary/#b","title":"B","text":"<p>Bid</p> <p>Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it.</p> <p>Burn</p> <p>Burning NFT effectively destroys the token and removes it entirely from the blockchain.</p>"},{"location":"getting-started/glossary/#c","title":"C","text":"<p>Collection</p> <p>NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted.</p> <p>Continuation</p> <p>Continuation token from the previous response.</p> <p>Contract</p> <p>Address of the Smart Contract.</p> <p>Creator</p> <p>Address of the NFT item creator.</p>"},{"location":"getting-started/glossary/#e","title":"E","text":"<p>ERC-20</p> <p>The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token.</p> <p>ERC-721</p> <p>The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract.</p> <p>ERC-1155</p> <p>The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.</p>"},{"location":"getting-started/glossary/#i","title":"I","text":"<p>Item</p> <p>Address of the NFT item. Id of the Item has format <code>${contract}:${tokenId}</code>.</p>"},{"location":"getting-started/glossary/#f","title":"F","text":"<p>Fee</p> <p>Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.</p>"},{"location":"getting-started/glossary/#l","title":"L","text":"<p>Lazy Mint</p> <p>The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.</p>"},{"location":"getting-started/glossary/#m","title":"M","text":"<p>Make</p> <p>Make the side of the Order. Make - what maker (order creator) has.</p> <p>Maker</p> <p>Creator of the order.</p> <p>Mint, Minting</p> <p>Minting is the act of publishing a unique instance of the token on the blockchain.</p>"},{"location":"getting-started/glossary/#n","title":"N","text":"<p>NFT</p> <p>Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.</p>"},{"location":"getting-started/glossary/#o","title":"O","text":"<p>Origin Fee</p> <p>Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize.</p> <p>Owner</p> <p>Address of the NFT item owner.</p> <p>Ownership</p> <p>Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format <code>${contract}:${tokenId}:${owner}</code>.</p>"},{"location":"getting-started/glossary/#p","title":"P","text":"<p>Payouts</p> <p>Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users.</p> <p>Platform</p> <p>The platform where the order was created.</p>"},{"location":"getting-started/glossary/#r","title":"R","text":"<p>Royalties</p> <p>Fees that are usually paid to the creator on every sale.</p>"},{"location":"getting-started/glossary/#s","title":"S","text":"<p>Salt</p> <p>Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash.</p> <p>Smart Contract</p> <p>The programs stored on a blockchain that run when predetermined conditions are met.</p> <p>Supply</p> <p>Total number of tokens minted or to be minted.</p>"},{"location":"getting-started/glossary/#t","title":"T","text":"<p>Take</p> <p>Take the side of the order, what order creator wants to get in return for <code>make</code> side.</p> <p>Token ID</p> <p>Token identifier.</p>"},{"location":"getting-started/instagram-to-nft-part-1/","title":"Instagram to NFT service with Rarible Protocol. Part 1","text":"<p>In this tutorial, you're going to learn how you can build a CocoNFT clone. What is CocoNFT, you\u2019d probably ask? It\u2019s a service that allows you to mint your Instagram posts as NFTs.</p> <p>Project is splitted into a 2 part series. Including everything into one article would feel overwhelming.</p> <p>In the first part (the one you\u2019re currently reading), we're going to explain how to let users Authorize their Instagram accounts on the app, so they can fetch their photos.</p> <p>In the second part, we\u2019re going to dive deeper into integrating the application with Metamask and many different wallets. This will allow users to interact with a bunch of different blockchains, such as Polygon, Ethereum, Flow, Tezos, to name a few. All of this will be done using Rarible Protocol APIs/SDK.</p> <p>If you want to follow along with the finished code, here is the GitHub repo.</p>"},{"location":"getting-started/instagram-to-nft-part-1/#create-an-instagram-app-that-can-authorize-a-user","title":"Create an Instagram App that can authorize a user","text":"<p>Since scraping websites like Facebook or Instagram is a daunting task, it\u2019s much easier to just use their API, because, well\u2026 they provide it. First, you have to go to the Facebook for Developers website. There, you have to go to \u201cMy Apps\u201d.</p> <p></p> <p>Click the big green button \u201cCreate an app\u201d (no screenshot included here, because you won\u2019t miss it for sure).</p> <p></p> <p>After that, you can choose an app type. There are quite a few different types here, but let\u2019s select \u201cConsumer\u201d.</p> <p></p> <p>From here, we can set up more products. Since we\u2019re focused on Instagram, click the \u201cSet Up\u201d button under the \u201cInstagram Basic Display\u201d option.</p> <p></p> <p>From now on, you should see Instagram\u2019s Basic Display on the left sidebar. If you\u2019re following this tutorial, you should also see a big red error. Don\u2019t worry, we\u2019re going to solve it now.</p> <p>Go to Settings &gt; Basic. You can then see App ID and App Secret. While we\u2019re on top of the page, you should also add the Privacy Policy URL and User Data Deletion. These fields are mandatory. What\u2019s funny is that it can be a totally fake URL (that would kinda breach the ToS of Meta and GDPR, I think). It just needs to have HTTPS and return status 200. I\u2019m using httpstat.us/200 which is basically a tool that always returns the 200 status code.</p> <p></p> <p>There is one more thing that we have to do while we are still on the Settings / Basic page: adding a platform. Localize a big \u201c Add Platform\u201d button on the bottom, click on it, and you should see the following popup. Select the website option.</p> <p></p> <p>Add a website URL.</p> <p></p> <p>After we filled in all required URLs and added a platform, we are able to create a New App on Instagram Basic Display.</p> <p></p> <p>You\u2019ll need to provide the correct URLs. This step is very important, because the Valid OAuth Redirect URI is an address where the Instagram Authorize window will redirect you with the Authorization Token as a query parameter. So in an ideal scenario, you would pass your backend API address here, save the token in the database, and then redirect the user to the proper page.</p> <p></p> <p>The next step is to add the following options to submission. They are required to allow us to fetch user data.</p> <p></p> <p>Okay, the setup step is already done\u2026 almost \ud83e\udd70.</p> <p>You also have to add an Instagram test user to be able to use the Instagram API in development mode. You can do it by going to Roles / Roles on the sidebar, and adding Instagram testers.</p> <p></p> <p>Finally\u2026 the last step. You have to agree on becoming a test user. You can do it by going to Instagram &gt; Settings &gt; Apps and Websites.</p> <p></p> <p>That\u2019s the end of the 1st section. You\u2019ve learned:</p> <ul> <li>How to create a Facebook App</li> <li>How to create an Instagram App</li> <li>How to invite a Test User</li> </ul>"},{"location":"getting-started/instagram-to-nft-part-1/#get-all-necessary-tokens-needed-to-get-user-medias","title":"Get all necessary tokens needed to get user medias","text":"<p>When it comes to the tokens, we\u2019ll need:</p> <p>1. Authorization Token \u2014 The one we receive after informing we want to authorize our app. The Authorization Token is one-time usage only, but if you mess this step up don\u2019t worry, you can always show it again.</p> <p></p> <p>2. Short-Lived Token \u2014 At this stage, we have an Authorization Token, which we can trade for the Short-Lived Token. It allows us to query the Instagram API for 60 minutes! That\u2019s where its name came from. But we can also go one step further, and trade it for\u2026</p> <p>3. Long-Lived Token \u2014 After obtaining it, you\u2019re able to use it for up to 60 days. You\u2019re also able to extend it after 24 hours from creating it. What it means in practice, is that you will not have to ask a user for an Authorization again. Big UX win! \ud83d\udc4a</p> <p>Before we learn how we can obtain it, you should prepare the two values below. They will interchange in a lot of requests.</p> <ul> <li><code>APP_ID</code></li> <li><code>APP_SECRET</code></li> </ul> <p>We can get both of them on the FB For Developers Instagram Panel.</p>"},{"location":"getting-started/instagram-to-nft-part-1/#authorization-token","title":"Authorization Token","text":"<p>In order to retrieve the Authorization Token, first, we have to prepare the following URL:</p> <pre><code>https://api.instagram.com/oauth/authorize?client_id=6201234567890178&amp;redirect_uri=https://httpstat.us/200&amp;scope=user_profile,user_media&amp;response_type=code\n</code></pre> <p>You\u2019ll need a few parameters here. <code>client_id</code>,<code>redirect_uri</code>, the scope of granted access. We talked about all of them earlier. After the URL creation, simply paste it to the browser. Then, the authorize page will pop up like it was shown earlier. Click on Authorization, and it will take you to the Redirect URI, which you\u2019ve provided, but (and that\u2019s the fun part) with an added code parameter. An example of a URL looks like this:</p> <pre><code>https://httpstat.us/200?code=AQBvJwCZtYdj1zLH_5myoAA1GRRpDhs1vcHFMzB4gvRk6dLkq5dNd24EVZ5FD9WoqQhfSuo6arUB17MPu2gRqEzP6EpsAl-9_2eC9-L6mWYQdWDyarkwDSNEs8T3gvoH-WLMHzhwwd6DJqP5PxJGf2ve53m7aGMEua3MzV8FZQVz5AfwWPN3G87n25jMBGgGGVj6G4pxJ9HqzNKmdpYK8GHKnRn_G03scHtUraFlEX5faCvz6ZO7Xw#_\n</code></pre> <p>This is the code we require, so copy it and delete the last two characters, \u201c#_\u201d to be precise. They are always added, and you have to delete them.</p>"},{"location":"getting-started/instagram-to-nft-part-1/#short-lived-token","title":"Short-Lived Token","text":"<p>In order to obtain this one, we\u2019ll need to do a POST request with form data added. We\u2019ll need:</p> <ul> <li><code>CLIENT_ID</code> \u2014 which you can grab on FB For Developers / Instagram Display Page, it\u2019s called App ID on the page</li> <li><code>CLIENT_SECRET</code> \u2014 same as above, only it\u2019s located to the right</li> <li><code>GRANT_TYPE</code> \u2014 \u201cauthorization_code\u201d</li> <li><code>REDIRECT_URI</code> \u2014 redirection URI which you\u2019ve provided</li> <li><code>CODE</code> \u2014 authorization token which we obtained in the previous step</li> </ul> <p>If you\u2019re using Postman, which I highly recommend for doing HTTP requests, your page should look similar to mine. Names in between curly braces are called Environment Variables. You can set them in global, and reuse them throughout the app.</p> <pre><code>https://api.instagram.com/oauth/access_token\n</code></pre> <p></p> <p>After sending a successful request, you should see the following answer.</p> <p></p> <p>If you mess something up, just read the error description and repeat the step to obtain the Authorization Token. Remember that it can only be used once. Going back to response values, <code>access_token</code> is our short-lived token, and <code>user_id</code> is, well, our user ID. It doesn\u2019t change at all, so you can also store it in the Global Vars on Postman.</p> <p>Congratulations! You\u2019re now able to fetch user data! For now, it\u2019s valid only for 60 minutes, so let\u2019s work on that right now.</p>"},{"location":"getting-started/instagram-to-nft-part-1/#long-lived-token","title":"Long-Lived Token","text":"<p>In order to change the Short-Lived Token into the Long-Lived one, you\u2019re going to have to do a GET request to this address:</p> <pre><code>https://graph.instagram.com/v13.0/access_token?client_secret={{APP_SECRET}}&amp;access_token={{ACCESS_TOKEN}}&amp;grant_type=ig_exchange_token\n</code></pre> <p></p> <p>In exchange, you\u2019ll get a self-explanatory response. Grab an access_token value, and you\u2019re good to go. You have a Long-Lived Token, now!</p> <p></p>"},{"location":"getting-started/instagram-to-nft-part-1/#fetch-media-details","title":"Fetch media details","text":"<p>We\u2019ve come a long way, but we\u2019re finally here! After creating an Instagram App and getting a Long-Lived Token, we\u2019re now ready to do some coding.</p> <p>Since we don\u2019t really have an HTTPS on localhost, we\u2019ll just use an <code>access_token</code> straight from the code. If you\u2019d like to go live with that, you just need to change a few things. Maybe create some sort of backend API, replace the Instagram Redirect URI to your website\u2019s one, and take it from there. This is just for tutorial purposes, so I won\u2019t do that here. Of course, there are a lot of different ways to achieve the same goal, so it\u2019s better to focus on concepts here.</p> <p>The URLs which you\u2019ll need in order to get those data are:</p> <p>1. Fetch IDs of user media</p> <pre><code>https://graph.instagram.com/v13.0/{{USER_ID}}/media?access_token={{LONG_LIVE_TOKEN}}&amp;fields=id,timestamp\n</code></pre> <p></p> <p>Ids are the <code>MEDIA_ID</code>.</p> <p>2. Fetch media URL, using previously obtained IDs</p> <pre><code>https://graph.instagram.com/v13.0/{{MEDIA_ID}}/media?access_token={{LONG_LIVE_TOKEN}}&amp;fields=media_url,media_type\n</code></pre> <p>Where <code>MEDIA_ID</code> are the IDs fetched earlier.</p> <p>Finally, \u2014 here comes my favourite part: </p> <p>To the code soldiers! \ud83e\udd73</p> <p>Compared to the work that we\u2019ve already done, it will be pretty quick.</p> <p>1. Fetch IDs of users\u2019 media</p> <p></p> <p>2. Fetch portion of retrieved posts</p> <p>Since there is an API requests rate limit, which equals 200 requests per hour per token, I prefer to fetch posts in portions when a user actually wants to fetch more than X. Thanks to that, we\u2019re saving our requests rate, as well as internet throughput.</p> <p></p> <p>3. Display fetched media</p> <p></p> <p>In the final step, you just have to map the media details array and use <code>media_url</code> as an image source.</p>"},{"location":"getting-started/instagram-to-nft-part-1/#summing-it-up","title":"Summing it up","text":"<p>We know that the article was quite big, but look how much you've done. You\u2019ve created an Instagram App, set it up, authorized a user, created a long-lived token, fetched IDs of users\u2019 media, got media URLs, and in the final step, displayed it.</p> <p>Feel free to read it again, especially the token creation part, just to understand better how the flow works.</p> <p>In the second part, you'll implement the NFT creation out of Instagram posts.</p>"},{"location":"getting-started/instagram-to-nft-part-2/","title":"Instagram to NFT service with Rarible Protocol. Part 2","text":"<p>Let\u2019s continue our journey to create a CocoNFT clone, a service that allows you to connect your Instagram and mint your posts as NFTs. Today, we are going to work on the process of creating NFT\u2019s out of the Instagram posts.</p> <p>Before we start, check out the first part. </p>"},{"location":"getting-started/instagram-to-nft-part-2/#setting-up-a-connector","title":"Setting up a connector","text":"<p>When it comes to the <code>connector-setup.tsx</code> file, there aren\u2019t many changes you\u2019ll need to perform. It\u2019s important, though, to know what\u2019s happening. In this file, we set up available wallets. All available providers and their implementation can be found here. We\u2019ve included just the Metamask and FCL wallet for the sake of simplicity. The most critical variable in this file is a \u201cconnector\u201d, which allows us to connect to the desired wallets.</p> <p>As you can see, we create it wi th injected and state variables, and then, in case we want to add other options, we call add on the method chain. Summing it up, I think that it\u2019s safe to say that we use a connector only to initialize wallet implementations and export them so that we can use them elsewhere.</p>"},{"location":"getting-started/instagram-to-nft-part-2/#creating-sdkwalletconnector-wrapper","title":"Creating <code>SdkWalletConnector</code> Wrapper","text":"<p>In the <code>SdkWalletConnector</code> element, the most important is the \"if\" statement. Here, we can control what we display in different connection statuses.</p> <p>For example, if the connection status is either disconnected or connecting, we display the option\u2019s element, which is responsible for showing the wallet connect buttons. It\u2019s essential to remember that we will wrap a whole app in this element because we want to have access to the SDK in every place. This means that the child element which we\u2019re passing as an argument is basically the page.</p> <p>Let\u2019s have a short recap of what we\u2019ve gone through so far. If the connection status is either \u201cdisconnected\u201d or \u201cconnecting\u201d on the screen, we\u2019ll see only the connect buttons because we\u2019re not displaying the child element here.</p> <p>The option element is pretty simple. We take all we added to connector wallets (what we added to <code>Connector.create(injected, state). add(fcl)</code> ), and iterate through them. If you would like to create a unique button style for every wallet, you should use the \u201coption\u201d key from objects, which we get back from the <code>connector.getOptions()</code> function.</p> <p></p> <p>Going back to the if statement, in case we manage to successfully connect to the wallet, we create an SDK and display a disconnect button in accordance with the child element, which is our page.</p>"},{"location":"getting-started/instagram-to-nft-part-2/#creating-sdkcontext","title":"Creating <code>SDKContext</code>","text":"<p>Since we want to be able to use SDK on every page, we elevate the possibilities that React gave us and create a context object.</p>"},{"location":"getting-started/instagram-to-nft-part-2/#wrapping-an-app-in-a-sdkwalletconnector-as-well-as-in-an-sdkcontext","title":"Wrapping an app in a <code>SdkWalletConnector</code> as well as in an <code>SDKContext</code>","text":"<p>It\u2019s time to put everything we\u2019ve already created in place. First, we wrap the whole app in a <code>SdkWalletConnector</code>, since it\u2019s the element that creates an SDK for us. After that, we pass the <code>SDKContext</code> which allows us to use the SDK out of the box in all of our pages. Then, we simply pass a <code>Component</code> element.</p>"},{"location":"getting-started/instagram-to-nft-part-2/#using-an-sdk-to-mint-an-nft","title":"Using an SDK to mint an NFT","text":"<p>If you had the chance to read our previous article/articles, this part will probably look familiar to you. Let\u2019s start the coding journey once again!</p> <p>Since this article is only dedicated to the NFT creation part, we won\u2019t cover the code from the first part.</p> <p>First and foremost, we need an IPFS connection in order to be able to save our NFT on IPFS.</p> <p></p> <p>The process of adding data to IPFS is pretty straightforward. We\u2019ll connect to the appropriate node (we use the Infura one in this example). Then, we just wait for the add method. In the return statement, we need to append <code>\u201cipfs:/\u201d</code> to the beginning since it\u2019s the required format.</p> <p></p> <p>In this step, we do as follows:</p> <ol> <li>Save post details on IPFS, and get its URI/CID address back.</li> <li>Define Rarible Smart Contract on Rinkeby address.</li> <li>Prepare mint request.</li> <li>Call <code>sdk.nft.mint</code> method with previously defined <code>mintRequest</code> as an argument, from the response you can also get additional info about minting possibilities such as: is lazy minting enabled?, or is multiple minting enabled?</li> <li>Submit the response (this line will open a Metamask window, so you can sign your transaction, it\u2019s cost-free).</li> </ol> <p>Result? Freshly created NFT!</p> <p></p> <p>If you want to check out your NFT, remember to use <code>https://rinkeby.rarible.com/token/{contractAddress}:{tokenId}</code> as a URL. For my specific example, it is:</p> <p>https://rinkeby.rarible.com/token/0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070</p>"},{"location":"getting-started/ipfs-example/","title":"Example of uploading &amp; using Metadata with IPFS","text":""},{"location":"getting-started/ipfs-example/#uploading-images-to-ipfs","title":"Uploading images to IPFS","text":"<p>To upload images to IPFS, we will use the Pinata service.</p> <p>Here you can see an example using Node JS to upload an image using the Pinata API.</p> <pre><code>const axios = require(\"axios\");\nconst fs = require(\"fs\");\nconst FormData = require(\"form-data\");\n\nexport const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) =&gt; {\n  const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`;\n  let data = new FormData();\n\n  data.append(\"file\", fs.createReadStream(\"./yourfile.png\"));\n\n  return axios.post(url, data, {\n      headers: {\n        \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`,\n        pinata_api_key: pinataApiKey,\n        pinata_secret_api_key: pinataSecretApiKey,\n      },\n    })\n    .then(function (response) {\n      console.log(repsonse.IpfsHash);\n    })\n    .catch(function (error) {\n      console.log(error)\n    });\n};\n</code></pre> <p>Response to the request:</p> <pre><code>{\n    IpfsHash: // This is the IPFS multi-hash provided back for your content,\n    PinSize: // This is how large (in bytes) the content you just pinned is,\n    Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format)\n}\n</code></pre>"},{"location":"getting-started/ipfs-example/#creating-a-metadata-file-for-nft","title":"Creating a Metadata file for NFT","text":"<p>With the <code>IpfsHash</code>, we can create a Metadata file. It will be connected to the NFT inside the blockchain network.</p> <pre><code>{\n   \"name\": /* NFT Name - This must be a string */,\n   \"description\": /* Description of the NFT - This must be a string */,\n   \"image\": /*  IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */,\n   \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */,\n   \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */,\n   // the below section is not needed.\n   \"attributes\": [\n      {\n         \"key\": /* Key name - This must be a string */,\n         \"trait_type\": /* Trait name - This must be a string */,\n         \"value\": /* Key Value - This must be a string */\n      }\n   ]\n}\n</code></pre>"},{"location":"getting-started/ipfs-example/#adding-generated-metadata-to-ipfs","title":"Adding generated Metadata to IPFS","text":"<ol> <li> <p>Specify <code>external_url</code> in the format <code>${contractAddress}:${tokenId}</code>, for example:</p> <pre><code>\"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\"\n</code></pre> </li> <li> <p>Publish Metadata to IPFS:</p> <pre><code>var axios = require('axios');\nvar data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]});\n\nvar config = {\n  method: 'post',\n  url: 'https://api.pinata.cloud/pinning/pinFileToIPFS',\n  headers: { \n    'pinata_api_key': // KEY_HERE, \n    'pinata_secret_api_key': // SECRET_KEY_HERE, \n    'Content-Type': 'application/json'\n  },\n  data: data\n};\n\naxios(config).then(function (response) {\n  console.log(JSON.stringify(response.data));\n}).catch(function (error) {\n  console.log(error);\n});\n</code></pre> <p>Response example:</p> <pre><code>{\n    \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\",\n    \"PinSize\": 290,\n    \"Timestamp\": \"2021-02-10T14:06:09.255Z\"\n}\n</code></pre> </li> <li> <p>Attach the new <code>IpfsHash</code> to your NFT.</p> </li> </ol>"},{"location":"getting-started/managing-sdk/","title":"Managing SDK and connecting blockchain wallets","text":"<p>We're glad you're here! It means that you gave us a chance. Now it's our turn.</p> <p>You are able to do cool things with NFTs using Rarible Protocol like:</p> <ul> <li>minting</li> <li>burning</li> <li>selling</li> <li>transferring</li> </ul> <p>And basically, everything else that you can imagine. There is just one step in-between, which is setting up an SDK.</p> <p>The fastest way to set up Multichain SDK is to clone the template which we prepared for you. It already has all the necessary packages installed.</p>"},{"location":"getting-started/managing-sdk/#configure-all-wallets-you-want-to-use","title":"Configure all wallets you want to use","text":"<p>In order to add a wallet of your choice (like fcl, mew, beacon, flow) you have to append chain it into Connector create in <code>src/sdk/connectors-setup</code> file. In sdk-template there is only Metamask implemented, if you want to add other ones, please refer to official tutorial there.</p> <pre><code>// Example of adding new wallet handler\nfunction mapEthereumWallet&lt;O&gt;(\n  provider: AbstractConnectionProvider&lt;O, EthereumProviderConnectionResult&gt;\n): ConnectionProvider&lt;O, WalletAndAddress&gt; {\n  return provider.map((state) =&gt; ({\n    wallet: new EthereumWallet(\n      new Web3Ethereum({ web3: new Web3(state.provider), from: state.address })\n    ),\n    address: state.address,\n  }));\n}\n\nconst mew = mapEthereumWallet(\n  new MEWConnectionProvider({\n    networkId: 4,\n    rpcUrl: ethereumRpcMap[4],\n  })\n);\n</code></pre> <p>After adding all the desired wallets, you have to chain them to the connector, with Metamask being first, in create method. It should look like that:</p> <pre><code>// Adding all wallets which you've earlier initalised\nconst connector = Connector.create(injected, state)\n  .add(torus)\n  .add(walletLink)\n  .add(mew)\n  .add(beacon)\n  .add(fcl)\n  .add(walletConnect);\n</code></pre>"},{"location":"getting-started/managing-sdk/#changing-buttons-appearance","title":"Changing buttons appearance","text":"<p>If you want to change buttons appearance (e.g. different one for Metamask, different one for flow), you can do it in <code>src/sdk/sdk-wallet-connector</code> file. To be precise, you can do it in the Options function, right where you see the o.option.</p> <p>Feel free to create a component for every button and just switch the <code>o.option</code> which basically is just a string literal of the wallet i.e. \"Metamask\", \"fcl\", etc.</p> <pre><code>function Options&lt;C&gt;({ connector, connectionState }: OptionsProps&lt;C&gt;) {\n  const options$ = useMemo(() =&gt; from(connector.getOptions()), [connector]);\n  return (\n    &lt;Rx value$={options$}&gt;\n      {(options) =&gt; (\n        &lt;div&gt;\n          {options.map((o) =&gt; (\n            &lt;div key={o.option}&gt;\n              &lt;button\n                className=\"p-2 border-radius border-gray-200 border-2\"\n                onClick={() =&gt; connector.connect(o)}\n              &gt;\n                Connect to {o.option}\n              &lt;/button&gt;\n              {connectionState.status === \"connecting\" &amp;&amp;\n              connectionState.providerId === o.provider.getId()\n                ? \"Connecting...\"\n                : null}\n            &lt;/div&gt;\n          ))}\n        &lt;/div&gt;\n      )}\n    &lt;/Rx&gt;\n  );\n}\n</code></pre>"},{"location":"getting-started/managing-sdk/#app-setup","title":"App setup","text":"<pre><code>function MyApp({ Component, pageProps }) {\n  return (\n    &lt;SdkWalletConnector connector={connector}&gt;\n      {(sdk, wallet, connection) =&gt; {\n        return (\n          &lt;SDKContext.Provider value={{ sdk, wallet, connection }}&gt;\n            &lt;Component {...pageProps} /&gt;\n          &lt;/SDKContext.Provider&gt;\n        );\n      }}\n    &lt;/SdkWalletConnector&gt;\n  );\n}\n</code></pre> <p>Setup of an App is pretty easy, you basically don't have to change anything there, but if you're curious \u2014 SdkWalletConnector is a file where we create buttons from a connector that we defined in the first step. </p> <p>It's responsible for showing a different view according to the current connection state. If the user has not connected his wallet, yet it will show a different view, and if he has connected his wallet it will show a Component function, which in that is just the desired page, on which we'll be able to use an SDK.</p> <p>SDKContext is just a wrapper that holds information about SDK, wallet, and connection, so you can easily, and without any trouble, use it on every page.</p> <pre><code>// Just like that\nconst { sdk, wallet } = useSdkContext();\n</code></pre>"},{"location":"getting-started/managing-sdk/#tldr","title":"TLDR","text":"<p>When setting up the SDK, there are three main files:</p> <ul> <li>connectors-setup \u2014 responsible for desired wallet's configuration</li> <li>sdk-wallet-connector \u2014 responsible for buttons appearance and wrapping a whole app</li> <li>app.js \u2014 which we wrap inside <code>SDKWalletConnector</code> and <code>SDKContext</code>, so we can have easy access to SDK on every page from now on</li> </ul>"},{"location":"getting-started/nft-101/","title":"NFT 101: What you need to know, before buying your first NFT","text":"<p>This article is a non-technical one, and its main goal is to help you feel comfortable navigating the different marketplaces and buying your first NFTs.</p>"},{"location":"getting-started/nft-101/#wallets","title":"Wallets","text":"<p>First things first. On the internet, everything that involves possession needs some sort of authentication. In a blockchain, we achieve this by using wallets. A wallet is a pair of private and public keys, which can be used to sign a transaction and verify your identity. The private key should always be securely stored securely, because if anyone gets it, they will be able to do anything they want with your possessions (tokens, NFTs, etc.), even take them away from you. \ud83d\ude28</p> <p>Metamask is the most commonly used wallet. It\u2019s a browser extension as well as a mobile app. You can install it on google extensions.</p> <p></p>"},{"location":"getting-started/nft-101/#common-marketplaces","title":"Common Marketplaces","text":"<p>Let\u2019s start with the question: what is an NFT marketplace after all? Every website can create its own marketplace. NFT marketplaces are nothing more than places where NFTs are accumulated and that allow users to interact and take actions towards these NFTs, e.g. buying, selling, transferring. On the marketplace, you can search for NFTs, create (or mint) them, or buy them from someone else.</p> <p>Some examples of big marketplaces out there would be:</p> <ul> <li> <p>OpenSea</p> <p>OpenSea is the biggest NFT marketplace out there. It has all sorts of different assets, it\u2019s free to sign up and it generally has an easy UX.</p> </li> <li> <p>Rarible</p> <p>Rarible is one of the biggest players out there. It supports NFTs on a few different chains, as well as a whole lot of different digital assets.</p> </li> <li> <p>There are not only big marketplaces out there</p> <p>There are a ton of different marketplaces out there. As I\u2019ve said earlier, anyone can create one. Some of them are exclusive to some use cases, like the Axie Marketplace which basically revolves around the Axie Infinity game, or NiftyGateway which works exclusively with NFT drops.</p> <p>There are also small, private marketplaces. Metaangels or Wanderers can be two examples of those. Since they\u2019re white-labeled by Rarible it means that they can be trusted, are safe to use, and reliable. In any case, remember to follow your instincts and if something looks shady, it\u2019s better to always check it a second time. You can end up with no support and no one to contact about stolen funds. We\u2019re (currently) in the wild west, baby \ud83d\ude0e</p> </li> </ul>"},{"location":"getting-started/nft-101/#nfts-properties","title":"NFTs properties","text":"<p>Okay, we already know some things about NFTs. We know that in order to create our account we will need a wallet, and we know where to find NFTs for sale. Technically speaking, we can create an NFT out of anything, but as I mentioned in the beginning this is not a technical article, so we\u2019re gonna focus only on what you can expect to see on a usual NFT, displayed on marketplaces.</p> <p></p> <p>Basically, every NFT you\u2019ll see on marketplaces will have a similar information structure. Let\u2019s break them down even further.</p> <ul> <li> <p>Visual asset</p> <p>Almost every NFT will represent some sort of a visual asset. It can be a gif, video, mp4, 3D model, or an image.</p> </li> <li> <p>Title</p> <p>A title is simply a name that we assign to an NFT, it doesn\u2019t have to be unique. After all, every NFT, even if it looks exactly the same as another one, is unique on its own.</p> </li> <li> <p>Collection</p> <p>This one is important. Basically, the collection allows us to know from which origin the NFT was created. As said earlier, nothing stops you from creating exactly the same NFT as someone else. Collections, on the other hand, are the guarantees of an origin. Often, they come as smart contracts created for this purpose. So you should always check the collections you\u2019re buying from. \u2705</p> </li> <li> <p>Attributes</p> <p>Attributes are additional properties that creators can add to the NFT. If they\u2019re creating an NFT game, maybe they can add strength or agility properties that will represent some functions in the app.</p> </li> </ul> <p>How can you find out if a collection is valid?</p> <p>The best way to do that, is to access the website of the project you want to buy. Let\u2019s say it\u2019s BAYC. You can go to their website, which you can identify thanks to the HTTPS, and you look for the marketplace\u2019s link (here\u2019s Rarible\u2019s). You then look for the collection address which is a hex address of the contract. It looks like this : \u201c0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\u201d.</p> <p></p> <p>On Rarible, you can even see the verified badge, in addition to the project\u2019s website and collection address. Basically, collections allow you to check if the NFT you want to buy is a legit, original NFT from the right author, and not a \u201cfake Gucci\u201d.</p> <p>How can you find the collection you\u2019re looking for?</p> <p>If you know what you\u2019re looking for, the best way to check if the collection is legitimate, it\u2019s to start by looking into the project\u2019s website. If it\u2019s a professional, and public project it will have a link to its collection on marketplaces. If there\u2019s no link there, you can always search it by name on Rarible. If the collection shows a lot of transactions and volume on the marketplace, it\u2019s probably legit. If you can\u2019t find it on the marketplace website by doing a name search, try to find its collection address. If you can\u2019t find that too, then there\u2019s not much you can do to verify the authenticity of that NFT.</p> <p>Remember that NFTs can be spread between different marketplaces, but if you see an NFT on Rarible, it doesn\u2019t mean that it\u2019s automatically on every other marketplaces out there.</p> <p></p> <p>As you can see in the image above, there are plenty of different BAYC collections, but in most cases, you can easily distinguish the original from the fake one.</p> <p></p> <p>In the same way, you can search for a collection by using its contract address, which will return the exact collection you\u2019re looking for.</p> <p>How to search for collections by a creator?</p> <p>This situation is identical to the previous one. Let\u2019s say that you\u2019re looking for NFTs from the user \u201cDaxio\u201d. You can identify him by his username or wallet address.</p> <p></p> <p></p> <p>On his profile, you can see his wallet address, and even on which blockchain it is. As you can see in this example, the wallet address is from the Polygon blockchain.</p>"},{"location":"getting-started/nft-101/#nft-ownership","title":"NFT ownership","text":"<p>The owner of the NFT is actually the wallet address where that NFT is located at the moment. Ownership can change, of course, simply by selling that NFT, transferring it, or burning it.</p>"},{"location":"getting-started/nft-101/#how-to-check-nft-overall-ownership","title":"How to check NFT overall ownership","text":"<p>1. Using marketplaces</p> <p>On Rarible, you can scan through the NFT using the order book that exists for every NFT out there. You can see who was the previous owner, how much it was sold for in the past, and what are the current bids to that NFT. A lot of useful information about everything that happened to that NFT in the past.</p> <p></p> <p>2. Using etherscan</p> <p>If you\u2019re interested in knowing all of the transactions of a given NFT, you can also do it by checking it on etherscan. It\u2019s simple, but in order to accomplish that we\u2019ll need two things \u2014 the token id and contract address. We can get both from URL. Let\u2019s use this as an example: https://rarible.com/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:6416?tab=details</p> <p>As you can see, we have token/contract_address:tokenId. So in this case, the contract address is <code>0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d</code> and token Id is <code>6416</code>. After getting those, we can then check the NFT on etherscan. You can do it by searching through transactions on given collections, but it\u2019s much easier if you just create a link by yourself which is</p> <p>https://etherscan.io/token/contractAddress?a=tokenId</p> <p>if we use it with the previous example, it would look like this:</p> <p>https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d?a=6416</p> <p></p> <p>And voil\u00e1, you\u2019re now able to browse through all of the details straight from the source.</p>"},{"location":"getting-started/nft-app-in-60-minutes/","title":"Create an app that allows you to list and sell NFTs, in 60 minutes","text":"<p>In this tutorial, we\u2019ll use the Rarible protocol to create a simple, yet very practical application. In this app, users will be able to connect their Metamask wallet, see all the NFTs they own (on the Ethereum blockchain), AND list them for sale!</p> <p>Why dive deep into solidity and waste months on end developing and testing your own contract, when you can just use a complete and fully reliable solution FOR FREE? With only JS! \ud83d\ude04</p>"},{"location":"getting-started/nft-app-in-60-minutes/#without-further-ado-lets-dive-into-it","title":"Without further ado, let\u2019s dive into it!","text":"<p>The app has 3 screens:</p> <p>1. \u201cConnect wallet\u201d button screen</p> <p></p> <p>Since the functionality of our app is limited (showing only NFTs that are owned by the user), there\u2019s no need to show anything on this 1st screen if the user hasn\u2019t yet connected his/her wallet. This functionality is tied to events, so anytime a wallet is connected or disconnected, the content on the screen will be refreshed.</p> <p>2. \u201cSee your NFTs\u201d screen</p> <p></p> <p>The main screen of our app. We\u2019re using a nice loading technique, which shows pictures only after they are fully loaded (bonus: we're gonna show you how to do this also).</p> <p>3. \u201cList your NFT for sale\u201d screen</p> <p></p> <p>Here, we can create a sell order which can be accepted by others. The buyer will be able to sign the transaction, exchanging ETH tokens to the NFT ownership.</p> <p>If you\u2019re more comfortable working with code by your side, here is the GitHub repo link for this project:</p> <p>https://github.com/kolberszymon/nft-marketplace-tutorial</p> <p>Clone it and you\u2019ll be ready to go.</p>"},{"location":"getting-started/nft-app-in-60-minutes/#application-architecture","title":"Application architecture","text":"<p>Let\u2019s first talk a bit about why we are using what we are using. For the framework, we\u2019ve chosen NextJS. It has a clear project structure and provides routing out of the box.</p> <p>Every folder in the \u2018pages\u2019 folder, with an index file in it, is translated into a URL. It allows us to use the Static Site Generator which is a super cool feature, and, because NextJS is a React \u201crelative\u201d, we can also use context. We\u2019ll use it to wrap our app on EthereumContext, which tracks whether a wallet is connected or not. Regarding the Type Script, we\u2019ve mainly used it for educational purposes, so you can clearly see each type.</p>"},{"location":"getting-started/nft-app-in-60-minutes/#connect-metamask-button-screen","title":"\u201cConnect Metamask\u201d button screen","text":"<p>The most useful and important thing you can learn from this screen is how to properly create context. Let\u2019s analyse it.</p> <p></p> <p>As you can see, we\u2019ve imported two react functions, <code>createContext</code> &amp; <code>useContext</code>, to be able to create a context. After that, we define <code>ContextProps</code> which we\u2019ll be using across our screens. (Don\u2019t feel intimidated by that \u2018Partial\u2019 thing, it\u2019s just a way to create an empty context object in TypeScript \ud83d\ude09).</p> <p>We export <code>EthereumContext</code>, as well as <code>useEthContext</code>. <code>EthereumContext</code> will be needed to wrap an app component in it, and useEthContext will be used to retrieve currently stored values.</p> <p>Let\u2019s take a look at the <code>\\_app.tsx</code> file, which is the main file for NextJS apps.</p> <p></p> <p>As you can see, there are 2 <code>useEffect</code> here: one with an empty dependency array, and one watching web3 changes. The first one is responsible for checking if our browser supports web3 (in other words, it checks if Metamask is installed and if the window has an Ethereum global variable). If it doesn\u2019t, we create an event listener which will be triggered when Ethereum is initialised.</p> <p>The second one, allows us to always refresh the currently selected account when web3 changes.</p> <p></p> <p>The procedures above represent a pretty standard way to start a crypto project. We destructure the Ethereum property out of window objects, and then check if it\u2019s defined and if it\u2019s Metamask. After that, we set an event listener on the Ethereum object to set accounts, every time we switch an account or disconnect it. And last but not least, we set the web3 object.</p> <p>As you can see, <code>setCurrentlyConnectedAccount</code> is used strictly for refreshing purposes. It gets your Metamask accounts, and if it finds any, it sets the first one in the array as the currently used one. The first item on the list, returned from the <code>getAccounts</code> function, is always the currently chosen one.</p> <p>Now comes the best part: <code>\\_app.tsx</code> file.</p> <p></p> <p>All the hard work to set things up, paid off. Now, we just elegantly wrap the app on <code>EthereumContext.Provider</code>, pass in values previously defined, which will update automatically in case anything changes (since we\u2019ve set event listeners on those), and voil\u00e0! We don\u2019t have to worry about wallets anymore, the rest is strictly NFT related! \ud83e\udd29</p>"},{"location":"getting-started/nft-app-in-60-minutes/#see-your-nfts-screen","title":"\u201cSee your NFTs\u201d screen","text":"<p>Now, we\u2019ll learn how we can list owned NFTs. If you are working with Rarible, you can find the API documentation here. We will use the <code>getItemsByOwner</code> endpoint.</p> <p></p> <p>We first define the <code>NftItem</code> type. There are many more properties than these ones, as you can see on the screen of API response, but these four will suit our needs.</p> <p></p> <p>Pay attention to how we are using EthContext here. \u2728</p> <p></p> <p>These are all the logic needed in order to show owned NFTs. Thanks to Rarible API, you can literally do it in only a few lines. First, we need to fetch data from the Rarible API and, afterwards, map through a returned list in order to adjust it to the NftItem type. The <code>handleConnectWallet</code> button is used to connect your Metamask account. Yep, that\u2019s how you do it, with only ONE line of code!!! People are often scared of Web3, but actually coding in it is pretty simple\u2026</p> <p></p> <p>Let\u2019s wrap up the HTML rendering! We have three states here: not connected, connected but NFTs are not fetched yet, and ready. We show only what is needed. In the last case, we map all the NFTs, and render tiles for each one.</p> <p>Here\u2019s the bonus! If you want to create an image that will shimmer until it\u2019s fully loaded, this is how you do it:</p> <p></p> <p>Create an isLoaded state, which defines the img display type. If it\u2019s not loaded yet, it is set to none, otherwise it\u2019s a block type. Images have onLoad property which allows us to do something when the image is fully loaded. In this case we\u2019re simply setting isLoaded to true, which copes with our previous logic.</p> <p></p> <p>The CSS for this animation looks like this. You can find every source on github. Feel free to get \u201cinspired\u201d by that. And, yeah, by \u201cget inspired\u201d we've meant Ctrl+C , Ctrl+V . \ud83d\ude1b</p>"},{"location":"getting-started/nft-app-in-60-minutes/#list-your-nfts-for-sale-screen","title":"\u201cList your NFTs for sale\u201d screen","text":"<p>Okay, here is the most interesting part of this tutorial: how can we list an NFT for sale using Rarible? Let\u2019s see:</p> <p></p> <p>We\u2019re passing tokenId in the URL, so first, we need to retrieve it by using the next router. If <code>tokenId</code> exists, i.e. if somebody didn\u2019t pass the wrong URL, we\u2019ll fetch <code>tokenData</code> and <code>tokenSellOrder</code>. Unfortunately, these are two different endpoints, so we can\u2019t fetch token price and info in one request. Now let\u2019s move onto something very important, that can probably save you some time.</p> <p></p> <p>On Rarible, there are different endpoints depending on what chain you\u2019re currently using. Since we mostly use a testing chain for development purposes, it will rarely be api.rarible.com. All you have to do is specify the current network by choosing one from <code>NETWORKS</code> enum. You also have to import the <code>currentChainInfo</code> variable and use it.</p> <p>Hang on, we are almost done!!!</p> <p></p> <p>The button handler is pretty simple, since we have a good code structure. Here, we basically pass all the needed arguments and delegate it to the <code>createSellOrder</code> function.</p> <p></p> <p>There are a few types of sell orders, but in this case we\u2019re choosing <code>MAKE_ERC721_TAKE_ETH</code>, which literally means: I want to receive ETH tokens in exchange for my ERC-721 NFT.</p> <p></p> <p>In order to create a sell order, we have to provide the type of object that will match the request schema (this is based on EIP712). It\u2019s a basic \u2018copy and paste\u2019 mechanic, so you can\u2019t innovate too much in this part.</p> <p>After the object is created, we now want to sign it.</p> <p></p> <p>I know it looks odd at first glance, but it really isn\u2019t! Let\u2019s walk through it.</p> <p>First, we just \u2018stringfy\u2019 our data. In a nutshell, we\u2019re sending bytes to the contract so the object has to be in the form of a string. Then, we use a provider which, in our case, is Metamask, to allow the user to sign the transaction. Sig variable is all we need from this function.</p> <p>We\u2019ve created a template for our data in the form of an object, stringfied it to JSON format, signed it with Metamask and\u2026 that\u2019s basically it. We just have one last thing to do: add a signature. We\u2019re adding it to order, like this:</p> <p></p> <p>and we\u2019re ready to POST it!</p> <p>We\u2019ve include <code>raribleJson</code> as request body, set headers to <code>applicaction/json</code> and everything is ready. That\u2019s it! From now on, it is already saved on Rarible, so if we want to interact with that we do it through API requests. \ud83d\ude0a</p>"},{"location":"getting-started/nft-app-in-60-minutes/#summary","title":"Summary","text":"<p>It wasn\u2019t that hard, was it? In this tutorial we\u2019ve created a place to see your NFTs, as well as list them for sale. To do that, we used Rarible, which allows us to interact with smart contracts 100% through their API.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>It's a Quick Start Guide for starting using Multichain SDK.</p> <p>We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section.</p>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<p>Installing Rarible SDK using We3: <pre><code>yarn add @rarible/sdk\nyarn add tslib@2.3.1\nyarn add web3@1.5.0\n</code></pre></p> <p>or using Ethers:</p> <pre><code>yarn add @rarible/sdk\nyarn add tslib@2.3.1\nyarn add ethers@5.6.2\n</code></pre> <p>Check that the SDK is installed correctly:</p> <pre><code>npm view @rarible/sdk version\n</code></pre>"},{"location":"getting-started/quick-start/#using-sdk","title":"Using SDK","text":"<p>Create a project with the JS framework of your choice (we'll be using NextJS here).</p> <p>To properly set up the Rarible SDK, we need to follow standard Web3 practices.</p> <ol> <li>Grab the Ethereum object out of the global window object.</li> <li>Use it to create a new instance of Web3.</li> <li>Create a new instance of EthereumWallet class.</li> <li>Create Rarible SDK with a new instance of ethereumWallet, created in the previous step.</li> </ol> <p>In code, it looks like that (using TypeScript):</p> <pre><code>// Imports\nimport Web3 from \"web3\"\nimport { createRaribleSdk } from \"@rarible/sdk\"\nimport { EthereumWallet } from \"@rarible/sdk-wallet\"\nimport { Blockchain } from \"@rarible/api-client\"\nimport { Web3Ethereum } from \"@rarible/web3-ethereum\"\n\n// Code\nconst { ethereum } = window as any\nconst web3 = new Web3(provider)\nconst web3Ethereum = new Web3Ethereum({ web3 })\nconst ethWallet = new EthereumWallet(web3Ethereum)\nconst raribleSdk = createRaribleSdk(ethWallet, \"staging\")\n</code></pre> <p>If using Ethers you should use @rarible/ethers-ethereum library for creating an EthereumWallet. Here is an example of creating all supported providers:</p> <pre><code>// Imports\nimport type Wallet from \"ethereumjs-wallet\"\nimport Web3 from \"web3\"\nimport { ethers } from \"ethers\"\nimport { Web3Ethereum } from \"@rarible/web3-ethereum\"\nimport { EthersEthereum, EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\"\n\n// Code\nexport function createProviders(provider: any, wallet: Wallet) {\n    const web3 = new Web3(provider)\n    const ethersWeb3Provider = new ethers.providers.Web3Provider(provider)\n\n    return {\n        web3,\n        providers: [\n            new Web3Ethereum({ web3 }),\n            new EthersEthereum(new ethers.Wallet(wallet.getPrivateKeyString(), ethersWeb3Provider)),\n            new EthersWeb3ProviderEthereum(ethersWeb3Provider),\n        ],\n    }\n}\n\nconst ethWallet = new EthereumWallet(ethersEthereumProviderInstance)\nconst raribleSdk = createRaribleSdk(ethWallet, \"staging\")\n</code></pre> <p>In <code>createRaribleSdk</code>, we have several environment parameters:</p> <ul> <li><code>prod</code> (mainnet)</li> <li><code>testnet</code> (goerli)</li> </ul> <p>The difference between them is the chain Id and the Rarible API endpoint.</p> <p>And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected.</p>"},{"location":"getting-started/quick-start/#erc-721-nft-lazy-minting-sell","title":"ERC-721 NFT Lazy Minting &amp; Sell","text":"<p>Often users want to list their NFTs on the sale right after creation. For this case, use <code>mintAndSell</code> function, which allows you to do exactly that.</p> <pre><code>const currentWallet = wallet as EthereumWallet;\nconst makerAccount = await currentWallet.ethereum.getFrom();\n// Price in ETH\nconst price: number = 1;\nconst mintRequest: PrepareMintRequest = {\n  collectionId: toContractAddress(\n    \"ETHEREUM:CONTRACT_ADDRESS\"\n  ),\n};\nconst ethCurrency: EthErc20AssetType = {\n  \"@type\": \"ERC20\",\n  contract: toContractAddress(\n    \"ETHEREUM:CONTRACT_ADDRESS\"\n  ),\n};\nconst mintResponse = await sdk.nft.mintAndSell(mintRequest);\nconst response = await mintResponse.submit({\n  uri,\n  supply: 1,\n  lazyMint: true,\n  price,\n  creators: [\n    {\n      account: toUnionAddress(`ETHEREUM:${makerAccount}`),\n      value: 10000,\n    },\n  ],\n  currency: ethCurrency,\n});\n// Response:\n// ItemId\n// OrderId\n</code></pre> <p>See Reference overview page for more information about SDK usage.</p>"},{"location":"getting-started/royalties-on-a-external-collection/","title":"Setting Up Royalties on an External Collection","text":"<ol> <li>Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract</li> <li>Active Contract tab. Make sure Write as Proxy is selected near the top.</li> <li> <p>Click Connect to Web3.</p> <p></p> </li> <li> <p>Expand the setRoyaltiesByToken function to set the royalties for the entire collection.</p> <p>You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below.</p> <p>The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties.</p> <p>Below is an example of a tuple which gives the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) 1% royalties on items in the collection.</p> <p>The maximum royalties value is 10000 (100%).</p> <pre><code>[[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]]\n</code></pre> <p>In the screenshot below you can see that on the collection (0x4008c2482357632b06526b492c143f4e73ff1b0d) the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) receives 2.5% (250) Royalties.</p> <p></p> </li> <li> <p>Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction.</p> <p></p> </li> </ol> <p>Now that Royalties have been set up, royalties will be paid out on every sale in that collection.</p> <p>Below is an example of a purchase transaction with annotations on what each fee is for:</p> <p></p>"},{"location":"getting-started/sdk-react-example/","title":"Example application for connecting blockchain wallet","text":"<p>This example will help you get started with the Rarible SDK. You will know how to:</p> <ul> <li>Connect and configure connection providers and wallet connectors in the Rarible SDK.</li> <li>Connect the available wallets via the web application.</li> </ul> <p>Example Application is written using React. Also, you can try our prepared Example APP with advanced functionality.</p>"},{"location":"getting-started/sdk-react-example/#create-react-app","title":"Create React App","text":"<p>In the beginning, you will need to have Node.js and Yarn on your machine to create a new single-page application in React. Also, we will be use Typescript template.</p> <p>To create a project, run:</p> <pre><code>yarn create react-app my-app --template typescript\n</code></pre> <p>Go to the project folder:</p> <pre><code>cd my-app\n</code></pre>"},{"location":"getting-started/sdk-react-example/#install-dependencies","title":"Install dependencies","text":"<p>Our Example App will use some dependencies. To install them, run:</p> <pre><code>yarn add @rarible/connector @rarible/connector-helper @rarible/connector-beacon @rarible/connector-fcl \\\n         @rarible/connector-fortmatic @rarible/connector-iframe @rarible/connector-mew \\\n         @rarible/connector-phantom @rarible/connector-portis @rarible/connector-solflare \\\n         @rarible/connector-torus @rarible/connector-walletconnect @rarible/connector-immutablex-link \\ \n         @rarible/connector-walletlink @rarible/sdk @rarible/types\n</code></pre>"},{"location":"getting-started/sdk-react-example/#connectors-setup","title":"Connectors setup","text":"<p>Create the <code>src/connector</code> folder and <code>connectors-setup.ts</code> file there. It lists all the wallets that our application can connect to.</p> connectors-setup.ts <pre><code>import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\"\nimport { RaribleSdkEnvironment } from \"@rarible/sdk/build/config/domain\"\nimport {\n    ConnectionProvider,\n    Connector,\n    IConnectorStateProvider,\n    InjectedWeb3ConnectionProvider,\n} from \"@rarible/connector\"\nimport { FclConnectionProvider } from \"@rarible/connector-fcl\"\nimport { MEWConnectionProvider } from \"@rarible/connector-mew\"\nimport { BeaconConnectionProvider } from \"@rarible/connector-beacon\"\nimport { TorusConnectionProvider } from \"@rarible/connector-torus\"\nimport { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\"\nimport { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\"\nimport { PhantomConnectionProvider } from \"@rarible/connector-phantom\"\nimport { SolflareConnectionProvider } from \"@rarible/connector-solflare\"\nimport type { IWalletAndAddress } from \"@rarible/connector-helper\"\nimport { mapEthereumWallet, mapFlowWallet, mapSolanaWallet, mapTezosWallet, mapImmutableXWallet } from \"@rarible/connector-helper\"\n// import { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\"\n// import { PortisConnectionProvider } from \"@rarible/connector-portis\"\n\n\nconst ethereumRpcMap: Record&lt;number, string&gt; = {\n    1: \"https://node-mainnet.rarible.com\",\n    3: \"https://node-ropsten.rarible.com\",\n    4: \"https://node-rinkeby.rarible.com\",\n    17: \"https://node-e2e.rarible.com\",\n    137: \"https://polygon-rpc.com\",\n    80001: \"https://rpc-mumbai.matic.today\"\n}\n\nconst ethereumNetworkMap: Record&lt;number, string&gt; = {\n    1: \"mainnet\",\n    3: \"ropsten\",\n    4: \"rinkeby\",\n    17: \"e2e\",\n    137: \"polygon\",\n    80001: \"mumbai\"\n}\n\nfunction environmentToEthereumChainId(environment: RaribleSdkEnvironment) {\n    switch (environment) {\n        case \"prod\":\n            return 1\n        case \"dev\":\n            return 3\n        case \"e2e\":\n            return 17\n        case \"staging\":\n        default:\n            return 4\n    }\n}\n\nfunction environmentToFlowNetwork(environment: RaribleSdkEnvironment) {\n    switch (environment) {\n        case \"prod\":\n            return {\n                network: \"mainnet\",\n                accessNode: \"https://access.onflow.org\",\n                walletDiscovery: \"https://flow-wallet.blocto.app/authn\",\n            }\n        case \"dev\":\n        case \"e2e\":\n        case \"staging\":\n        default:\n            return {\n                network: \"testnet\",\n                accessNode: \"https://access-testnet.onflow.org\",\n                walletDiscovery: \"https://flow-wallet-testnet.blocto.app/authn\",\n            }\n    }\n}\n\nfunction environmentToTezosNetwork(environment: RaribleSdkEnvironment) {\n    switch (environment) {\n        case \"prod\":\n            return {\n                accessNode: \"https://tezos-node.rarible.org\",\n                network: TezosNetwork.MAINNET\n            }\n        case \"dev\":\n        case \"e2e\":\n        case \"staging\":\n        default:\n            return {\n                accessNode: \"https://test-tezos-node.rarible.org\",\n                network: TezosNetwork.ITHACANET\n            }\n    }\n}\n\nfunction environmentToImmutableXEnv(environment: RaribleSdkEnvironment) {\n    switch (environment) {\n        case \"prod\":\n            return \"prod\"\n        default:\n            return \"dev\"\n    }\n}\n\nconst state: IConnectorStateProvider = {\n    async getValue(): Promise&lt;string | undefined&gt; {\n        const value = localStorage.getItem(\"saved_provider\")\n        return value ? value : undefined\n    },\n    async setValue(value: string | undefined): Promise&lt;void&gt; {\n        localStorage.setItem(\"saved_provider\", value || \"\")\n    },\n}\n\nexport function getConnector(environment: RaribleSdkEnvironment): Connector&lt;string, IWalletAndAddress&gt; {\n    const ethChainId = environmentToEthereumChainId(environment)\n    const ethNetworkName = ethereumNetworkMap[ethChainId]\n    const isEthNetwork = [\"mainnet\", \"ropsten\", \"rinkeby\"].includes(ethNetworkName)\n    const flowNetwork = environmentToFlowNetwork(environment)\n    const tezosNetwork = environmentToTezosNetwork(environment)\n\n    const injected = mapEthereumWallet(new InjectedWeb3ConnectionProvider())\n\n    const mew = mapEthereumWallet(new MEWConnectionProvider({\n        networkId: ethChainId,\n        rpcUrl: ethereumRpcMap[ethChainId]\n    }))\n\n    const beacon: ConnectionProvider&lt;\"beacon\", IWalletAndAddress&gt; = mapTezosWallet(new BeaconConnectionProvider({\n        appName: \"Rarible Test\",\n        accessNode: tezosNetwork.accessNode,\n        network: tezosNetwork.network\n    }))\n\n    const fcl = mapFlowWallet(new FclConnectionProvider({\n        accessNode: flowNetwork.accessNode,\n        walletDiscovery: flowNetwork.walletDiscovery,\n        network: flowNetwork.network,\n        applicationTitle: \"Rari Test\",\n        applicationIcon: \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\"\n    }))\n\n    let torus = undefined\n    if (isEthNetwork) {\n        torus = mapEthereumWallet(new TorusConnectionProvider({\n            network: {\n                host: ethNetworkName\n            }\n        }))\n    }\n\n    const walletLink = mapEthereumWallet(new WalletLinkConnectionProvider({\n        networkId: ethChainId,\n        estimationUrl: ethereumRpcMap[ethChainId],\n        url: ethereumRpcMap[ethChainId]\n    }, {\n        appName: \"Rarible\",\n        appLogoUrl: \"https://rarible.com/static/logo-500.static.png\",\n        darkMode: false,\n    }))\n\n    const walletConnect = mapEthereumWallet(new WalletConnectConnectionProvider({\n        rpc: ethereumRpcMap,\n        chainId: ethChainId,\n    }))\n\n    const phantomConnect = mapSolanaWallet(new PhantomConnectionProvider())\n    const solflareConnect = mapSolanaWallet(new SolflareConnectionProvider({\n        network: environment === \"prod\" ? \"mainnet-beta\" : \"devnet\"\n    }))\n\n    const imxConnect = mapImmutableXWallet(new ImmutableXLinkConnectionProvider({\n        env: environmentToImmutableXEnv(environment),\n    }))\n\n    // Providers required secrets\n    // const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } }))\n    // const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" }))\n\n    const connector = Connector\n        .create(injected, state)\n        .add(walletLink)\n        .add(mew)\n        .add(beacon)\n        .add(fcl)\n        .add(walletConnect)\n        .add(phantomConnect)\n        .add(solflareConnect)\n        .add(imxConnect)\n    // .add(portis)\n    // .add(fortmatic)\n\n    if (torus) {\n        return connector.add(torus)\n    }\n\n    return connector\n}\n</code></pre>"},{"location":"getting-started/sdk-react-example/#connection-provider","title":"Connection provider","text":"<p>Create the <code>sdk-connection-provider.tsx</code> file in <code>src/connector</code> folder. Connection provider needed for handling blockchain wallet connection and pass connection and SDK objects to React context for using them in any app components.</p> sdk-connection-provider.tsx <pre><code>import React, { useEffect, useState } from \"react\"\nimport { createRaribleSdk } from \"@rarible/sdk\"\nimport type { ConnectionState } from \"@rarible/connector\"\nimport { getStateDisconnected, IConnector } from \"@rarible/connector\"\nimport { IRaribleSdk } from \"@rarible/sdk/build/domain\"\nimport type { IWalletAndAddress } from \"@rarible/connector-helper\"\nimport { RaribleSdkEnvironment } from \"@rarible/sdk/build/config/domain\"\nimport { getConnector } from \"./connectors-setup\"\n\nexport interface IConnectorContext {\n    connector?: IConnector&lt;string, IWalletAndAddress&gt;\n    state: ConnectionState&lt;IWalletAndAddress&gt;\n    sdk?: IRaribleSdk\n    walletAddress?: string\n}\n\nexport const ConnectorContext = React.createContext&lt;IConnectorContext&gt;({\n    connector: undefined,\n    state: getStateDisconnected(),\n    sdk: undefined,\n    walletAddress: undefined\n})\n\nconst environment: RaribleSdkEnvironment  = \"development\"\n\nexport function SdkConnectionProvider({children}: {children: React.ReactNode}) {\n    const [context, setContext] = useState&lt;IConnectorContext&gt;()\n    const [sdk, setSdk] = useState&lt;IRaribleSdk&gt;()\n    const connector = getConnector(environment)\n\n    useEffect(() =&gt; {\n        const subscription = connector.connection.subscribe(s =&gt; {\n            const sdkInstance = s.status === \"connected\" ? createRaribleSdk(s.connection.wallet, environment) : undefined\n            setSdk(sdkInstance)\n            const computedContext: IConnectorContext = {\n                connector,\n                state: s,\n                sdk,\n                walletAddress: s.status === \"connected\" ? s.connection.blockchain + \":\" + s.connection.address : undefined,\n            }\n            setContext(computedContext)\n        })\n        return () =&gt; subscription.unsubscribe()\n//eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [])\n\n    return &lt;ConnectorContext.Provider value={context!}&gt;\n        {children}\n    &lt;/ConnectorContext.Provider&gt;\n}\n</code></pre>"},{"location":"getting-started/sdk-react-example/#usage-in-app","title":"Usage in APP","text":"<p>Create the <code>src/pages</code> folder and <code>main.tsx</code> file there. This will be the main page of our application.</p> main.tsx <pre><code>import React, { useContext, useEffect, useState } from \"react\"\nimport { ConnectorContext } from \"../connector/sdk-connection-provider\"\nimport { ProviderOption } from \"@rarible/connector\"\nimport type { IWalletAndAddress } from \"@rarible/connector-helper\"\nimport { toOrderId } from \"@rarible/types\"\n\nexport function MainPage() {\n    const [options, setOptions] = useState&lt;ProviderOption&lt;string, IWalletAndAddress&gt;[]&gt;([])\n    const connection = useContext(ConnectorContext)\n\n    useEffect(() =&gt; {\n        connection?.connector?.getOptions().then(o =&gt; {\n            setOptions(o)\n        })\n    }, [connection])\n\n    const connect = async (option: ProviderOption&lt;string, IWalletAndAddress&gt;) =&gt; {\n        await connection.connector?.connect(option)\n    }\n    const disconnect = async () =&gt; {\n        if (connection?.state.status === \"connected\" &amp;&amp; connection?.state?.disconnect) {\n            await connection?.state?.disconnect()\n        }\n    }\n\n    const someSdkAction = async () =&gt; {\n        const prepare = await connection?.sdk?.order.buy({orderId: toOrderId(\"orderid\")})\n        await prepare?.submit({amount: 1})\n    }\n\n    return &lt;div&gt;\n        Connection status: {connection?.state?.status}\n        &lt;div&gt;\n            &lt;button\n                disabled={connection?.state?.status !== \"connected\"}\n                onClick={disconnect}\n            &gt;\n                Disconnect\n            &lt;/button&gt;\n        &lt;/div&gt;\n        {options.map((option, i) =&gt; {\n            return &lt;div key={option.option}&gt;\n                &lt;button\n                    onClick={() =&gt; connect(option)}\n                    disabled={connection?.state?.status !== \"disconnected\"}\n                &gt;\n                    Connect {option.option}\n                &lt;/button&gt;\n            &lt;/div&gt;\n        })}\n    &lt;/div&gt;\n}\n</code></pre> <p>Now replace the contents of the <code>App.tsx</code> file with the following:</p> App.tsx <pre><code>import './App.css';\nimport {SdkConnectionProvider} from \"./connector/sdk-connection-provider\";\nimport { MainPage } from \"./pages/main\"\n\nfunction App() {\n    return (\n        &lt;SdkConnectionProvider&gt;\n            &lt;MainPage/&gt;\n        &lt;/SdkConnectionProvider&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>Check the project structure. It will be looks like this:</p> <p></p> <p>To start application, run in project folder:</p> <pre><code>yarn start\n</code></pre> <p>If everything is configured correctly, the app will open at the <code>http://localhost:3000/</code> address:</p> <p></p> <p>Now you can connect to any of the available wallets. For example, this is how the connection to MetaMask looks like.</p> <p></p> <p>That's it, now you have a working sample application on React! Try also our prepared Example APP with advanced functionality.</p>"},{"location":"getting-started/sdk-react-example/#polyfill-modules-in-webpack-5","title":"Polyfill modules in Webpack 5","text":"<p>If you are using webpack version 5 you may encounter errors with polyfill node core modules. Use the following steps to fix these errors:</p> <ol> <li> <p>Install <code>react-app-rewired</code> and missing dependencies</p> <pre><code>yarn add react-app-rewired crypto-browserify stream-browserify assert stream-http https-browserify \\\n         os-browserify url buffer process path-browserify\n</code></pre> </li> <li> <p>Override the create-react-app webpack config file</p> config-overrides.js <pre><code>/* config-overrides.js */\nconst webpack = require('webpack');\nmodule.exports = function override(config, env) {\n\n    config.resolve.fallback = {\n        url: require.resolve('url'),\n        assert: require.resolve('assert'),\n        crypto: require.resolve('crypto-browserify'),\n        http: require.resolve('stream-http'),\n        https: require.resolve('https-browserify'),\n        os: require.resolve('os-browserify/browser'),\n        buffer: require.resolve('buffer'),\n        stream: require.resolve('stream-browserify'),\n        path: require.resolve(\"path-browserify\")\n    };\n    config.plugins.push(\n        new webpack.ProvidePlugin({\n            process: 'process/browser',\n            Buffer: ['buffer', 'Buffer'],\n        }),\n    );\n\n    return config;\n}\n</code></pre> </li> <li> <p>Override <code>package.json</code></p> <p>Replace <code>react-scripts</code> with <code>react-app-rewired</code> scripts for the three following scripts fields to update the webpack configuration in <code>package.json</code> file. It will be looks like this:</p> <pre><code>\"scripts\": {\n  \"start\": \"react-app-rewired start\",\n  \"build\": \"react-app-rewired build\",\n  \"test\": \"react-app-rewired test\",\n  \"eject\": \"react-scripts eject\"\n},\n</code></pre> </li> <li> <p>To start application, run in project folder:</p> <pre><code>yarn start\n</code></pre> </li> </ol> <p>See more information about fixing polyfill node core modules here.</p>"},{"location":"getting-started/sellOrder_acceptBid/","title":"Create Sell Order and Accept Bid","text":"<p>After reading this piece of content you should have a knowledge about creating sell orders and accepting bids using Rarible Protocol.</p>"},{"location":"getting-started/sellOrder_acceptBid/#executing-actions","title":"Executing actions","text":"<p>You can use SDK to create (mint), trade, transfer, burn NFTs. All actions are handled in the same manner:</p> <ul> <li>Invoke function from SDK (e.g.: <code>mint</code>).</li> <li>Async function returns so-called <code>PrepareResponse</code> (it's different for different actions).</li> <li><code>PrepareResponse</code> contains all needed information to show user a form (for example, response for sell contains all supported currency types).</li> <li>Collect input from the user (show form and let user enter the data).</li> <li>Pass this data to submit Action.</li> </ul> <p>You can find more information about Action abstraction in dedicated [repo readme]. Or you can use it as a regular async function and work with regular Promises.</p>"},{"location":"getting-started/sellOrder_acceptBid/#multichain","title":"Multichain","text":""},{"location":"getting-started/sellOrder_acceptBid/#create-sell-order","title":"Create Sell Order","text":"<p>To create a sell order for NFT the following parameters are required:</p> <ul> <li><code>Item ID</code> \u2014 Id of an item passed in blockchain:address:id manner, e.g. <code>FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321</code>,</li> <li><code>Asset type</code> - Asset which you want to receive for your NFT, e.g. FLOW_FT, ERC_20,</li> <li><code>Price</code> - Amount of asset of your choice you want to receive,</li> <li><code>Contract Address</code> - Address of a given asset format, e.g. for FLOW_FT, which stands for Flow Fungible Token (so just a flow token) you have to pass a contract of a flow token, which on testnet is as follows: <code>A.7e60df042a9c0868.FlowToken</code>.</li> </ul> <p>You can find all of the information about its contract addresses here: https://docs.onflow.org/core-contracts/flow-token/#gatsby-focus-wrapper</p> <p>Whenever you see the need for Multichain / Contract address, you can create it as follows:</p> <ol> <li>Blockchain Name</li> <li>Hex Address</li> </ol> <p>Example:</p> <p><code>BlockchainName:HexAddress</code> = <code>ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05</code></p> <ol> <li>Get an id of the item you want to create a sell order for, e.g. by copying it from rarible URL when you're on your token, and create an orderRequest with that.    The only difference between different blockchains is currency, i.e. asset which we want to receive in return for our NFT.</li> </ol> <p>It should look something like that:</p> <ul> <li><code>FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321</code>,</li> <li><code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:47</code></li> <li><code>TEZOS:KT1BMB8m1QKqbbDDZPXpmGVCaM1cGcpTQSrw:443</code></li> </ul> <pre><code>import { toContractAddress, toItemId } from \"@rarible/types\";\n\n...\n\nconst itemId = \"FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321\";\n\nconst orderRequest: PrepareOrderRequest = {\n  itemId: toItemId(itemId);\n}\n</code></pre> <ol> <li>Create a currency which you want to receive in return.</li> </ol> <p>Available ones:</p> <ul> <li>FlowAssetTypeNft,</li> <li>FlowAssetTypeFt,</li> <li>TezosXTZAssetType,   etc.   You can find all of them in node_modules/@rarible/api-client/build/models/AssetType.d.ts of you project. Additionally you're able to find all of the needed properties for them like tokenId, @type, or contract.</li> </ul> <pre><code>const tezosAddress = \"TEZOS:KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS\"\nconst flowAddress = \"FLOW:A.7e60df042a9c0868.FlowToken\"\n\n// ETH\nconst currency: EthEthereumAssetType = {\n  \"@type\": \"ERC20\",\n  contract: toContractAddress(ethereumAddress)\n}\n\n// TEZOS\nconst currency: TezosFTAssetType = {\n  \"@type\": \"TEZOS_FT\",\n  contract: toContractAddress(tezosAddress),\n  tokenId: 2321\n}\n\n// FLOW\nconst currency: FlowAssetTypeFt = {\n  \"@type\": \"FLOW_FT\",\n  contract: toContractAddress(flowAddress)\n};\n</code></pre> <ol> <li>Get sell response using orderRequest from earlier</li> </ol> <pre><code>const sellResponse = await sdk.order.sell(orderRequest);\n\n// From sellResponse object you can get informations like:\n// is multiple sell order allowed\n// baseFee\n// maxAmount\n// originFeeSupport\n</code></pre> <p>Example of response</p> <pre><code>{\n  \"multiple\": false,\n  \"supportedCurrencies\": [\n    {\n      \"blockchain\": \"FLOW\",\n      \"type\": \"NATIVE\"\n    }\n  ],\n  \"baseFee\": 250,\n  \"originFeeSupport\": \"FULL\",\n  \"payoutsSupport\": \"NONE\",\n  \"maxAmount\": \"1\"\n}\n</code></pre> <ol> <li>Execute submit method on sellResponse object</li> </ol> <pre><code>const sellOrderCreated = await sellResponse.submit({\n  price: 1,\n  amount: 1,\n  currency: currency,\n});\n</code></pre> <p>Example of response</p> <pre><code>FLOW:33966044\n</code></pre> <p>Voila</p>"},{"location":"getting-started/sellOrder_acceptBid/#accept-bid","title":"Accept Bid","text":"<p>Accepting a bid codeflow is similar to the one in creating sell order. Codeflow is identical for all of the blockchains.</p> <ol> <li>Create fillRequest with an orderId which you want to accept</li> </ol> <pre><code>const orderId = \"FLOW:32732635\";\n\nconst fillRequest: PrepareFillRequest = {\n  orderId: toOrderId(orderId),\n};\n</code></pre> <ol> <li>Get fillResponse using fillRequest</li> </ol> <pre><code>const fillResponse = await sdk.order.acceptBid(fillRequest);\n</code></pre> <p>Example of response</p> <pre><code>{\n  \"multiple\": false,\n  \"maxAmount\": \"1\",\n  \"baseFee\": 250,\n  \"supportsPartialFill\": false,\n  \"originFeeSupport\": \"FULL\",\n  \"payoutsSupport\": \"NONE\"\n}\n</code></pre> <ol> <li>Submit received response</li> </ol> <pre><code>const fillSubmitResponse = await fillResponse.submit({\n  amount: 1,\n});\n</code></pre>"},{"location":"getting-started/solana-nft-app/","title":"Create your NFT app on Solana in 10 minutes","text":""},{"location":"getting-started/solana-nft-app/#what-is-solana","title":"What is Solana?","text":"<p>While ETH was reaching new heights in terms of traffic, price, and dApps development, new blockchains have arisen to tackle some of Ethereum\u2019s main problems. One of them is Solana, currently the 6th largest blockchain in terms of market valuation.</p> <p>Ethereum\u2019s main problems are, of course, transaction speed and enormous transaction fees. Solana did manage to solve these perfectly, allowing up to 65,000 transactions per second and reducing transaction costs to $0.00025 per transaction. Going further, Solana has its own programming language that lets us create dApps, NFTs, and more. Overall, it\u2019s a pretty solid competitor to Ethereum. \ud83c\udfc5</p>"},{"location":"getting-started/solana-nft-app/#why-is-solana-worth-trying","title":"Why is Solana worth trying?","text":"<p>As with every blockchain, there are a few things that make Solana unique. Let\u2019s look at some of Solana\u2019s technical features, which are also called the 8 innovations of Solana.</p> <ol> <li> <p>Proof-of-History</p> <p>In order to make communication cost and latency more efficient in conjunction with Proof-of-Stake, Solana integrates the concept known as a Proof-of-History. It\u2019s a clock before consensus is reached, i.e. before agreeing on a blockchain state. It uses a recursive verifiable delay function to hash incoming events and transactions. It massively reduces overhead, thereby allowing scalability.</p> </li> <li> <p>Sealevel</p> <p>\u201cA hyper parallelized transaction processing engine designed to scale horizontally across GPUs and SSD\u201d. All other blockchains are single-threaded. Solana changed this status quo and became the first blockchain that is able to support parallel transaction execution in a single shard. It means that the blockchain will only become faster with time, allowing, once again, massive scalability.</p> </li> <li> <p>Gulf Stream</p> <p>Solana found a way to manage a mempool size of 100,000. Other blockchains use \u201cgossip protocols\u201d to propagate their mempools, and since gossip protocol, as its name states, achieves its purpose by exchanging information between nodes, it gets overwhelmed. Gulf Stream pushes transactions caching and forwarding to the edge of the network. This makes it possible for validators to execute transactions ahead of time.</p> </li> <li> <p>60,000 Transactions Per Second (TPS)</p> <p>Currently, Visa / Mastercard can process up to 65,000 TPS, which sets the bar for the cryptocurrencies pretty high (if they ever wish to replace it). In comparison, Bitcoin can process up to 7 TPS, which is super low. Solana, on the other hand, due to the technical solutions listed above can process up to 60,000 TPS!</p> </li> </ol> <p>If you\u2019re curious and want a deeper explanation, you can find the perfect one here, written by Anatoly Yakovenko, a Co-Founder of Solana.</p>"},{"location":"getting-started/solana-nft-app/#solana-faucet-aka-give-me-free-funds","title":"Solana Faucet, aka \u201cGive me free funds!\u201d","text":"<p>Moving forward into the development phase. \ud83d\udc68\u200d\ud83d\udcbb As always, the first step when creating NFTs on any blockchain is to acquire the funds needed for transaction fees. Usually, we use a faucet service in order to get test funds. Solana is no different! After typing \u201cSolana Faucet\u201d on Google, we can see the following page:</p> <p></p> <p>Compared to Tezos, getting test funds on Solana is very simple. But first things first.</p> <p>Solana Wallet</p> <p>In order to sign and execute transactions, we need some sort of wallet. Unfortunately, since Solana is not compatible with Ethereum, we can\u2019t use Metamask, as it supports only Ethereum-based currencies. That\u2019s not a problem, though! Solana has a similar app named Phantom, which is a web browser extension as well as a mobile app wallet, so it\u2019s super convenient to use. It looks like this:</p> <p></p> <p></p> <p>If you want to change the network, you have to go to the settings page at the bottom and change the network to the desired one, which in our case is devnet.</p> <p>Important: in order to create NFTs, you have to be on devnet, and NOT on testnet; otherwise it won\u2019t work, since Rarible SDK doesn\u2019t support testnet.</p> <p>After that, click on \u201cDeposit\u201d, copy your wallet address, and paste it into the Solana Faucet. After approximately 0.002 seconds, we should have our test funds available. Ahh, the beauty of Solana. \u2600\ufe0f</p>"},{"location":"getting-started/solana-nft-app/#creating-nfts-on-solana-blockchain-using-rarible-sdk","title":"Creating NFTs on Solana blockchain using Rarible SDK","text":"<p>In order to create NFTs on Solana, we will use the exemplary app provided by Rarible. You can get it here:</p> <p>Rarible Protocol SDK</p> <p>The exemplary app is located on the <code>packages/example</code> in the repo below:</p> <p>Rarible SDK React Example</p> <p>In order to kickstart the project, you have to follow instructions disclaimed on Readme, which basically limits to running:</p> <pre><code>yarn &amp;&amp; yarn bootstrap &amp;&amp; yarn build-all\n</code></pre> <p>command from the root folder (not the <code>packages/example</code> folder).</p> <p>Exemplary Application</p> <p></p> <p>The coolest aspect of the exemplary application is that it showcases all the possibilities the SDK provides. It\u2019s also a fast way to validate what you can achieve with the Rarible SDK (which is a lot \ud83d\ude09).</p> <p>Connect Wallet</p> <p></p> <p>In order to create NFTs, we have to connect a wallet first, which in Solana\u2019s case is either Phantom or Solflare. As I stated earlier, I\u2019m going with Phantom. What\u2019s important here is to set the environment for \u201cdevelopment\u201d, that will allow you to use your wallet. After connecting, you should see the current status as \u201cconnected\u201d.</p> <p>Deploying Collection</p> <p></p> <p>In order to successfully deploy a collection, you have to pass a Metadata URI, which is a JSON with collection properties, usually stored on IPFS. It looks like this:</p> <pre><code>{\n   \"name\":\"Konosuba Characters\",\n   \"symbol\":\"KNSB\",\n   \"description\":\"test collection\",\n   \"seller_fee_basis_points\":0,\n   \"image\":\"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\",\n   \"properties\":{\n      \"files\":[\n         {\n            \"type\":\"image/png\",\n            \"uri\":\"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\"\n         }\n      ],\n      \"category\":\"image\",\n      \"creators\":[\n         {\n            \"address\":\"A4t9PGWWUwwRh\u2026\",\n            \"share\":100\n         }\n      ]\n   }\n}\n</code></pre> <p>You can find an explanation about all the available options for Metadata URI here. All fields are mandatory \u2014 properties and image may be empty. <code>Name</code>, <code>symbol</code>, and <code>description</code> are used to describe your token, <code>seller_fee_basis_points</code> is a royalties percentage, i.e. the percent of each following sale that will go to the creator. <code>Image</code> and <code>properties</code> are used for additional assets, and creators tell how the royalties should be distributed</p> <p>When it comes to uploading documents to IPFS, you can do it as you want. If you\u2019re interested in doing it from the code level, check one of our previous article, but you can also use Pinata for that purpose. After getting your Metadata URI, which is a link to JSON stored on IPFS, and which looks like this:</p> <p>https://gateway.pinata.cloud/ipfs/QmbDt5hsCCTE45twSGz33WorHr5vtii96rGsZNL6UfkrvW</p> <p>Paste it to the adequate field. The Phantom window should pop up, as it\u2019s shown below. Notice the predicted amount of SOL that will be subtracted from your account as a transaction fee.</p> <p>If you see \u201ctransaction may fail to confirm\u201d, it means that either you don\u2019t have enough funds, or you\u2019re connected to the wrong chain.</p> <p></p> <p>After a successful collection creation, you should see information about the created collection:</p> <p></p> <p>The most important information here is the collection address. With that, you can always fetch any related information from the Rarible API (see an article about that). After obtaining the collection id, we\u2019re able to create an NFT by going to the \u201cMint Token\u201d page.</p> <p>Minting a Token</p> <p></p> <p>As you can see, there are two steps involved in that process. The first one is passing a collection ID, and the second one is sending a transaction. What\u2019s super cool about the exemplary app is that, on the right side of the screen, there are always code snippets included. You\u2019re able to examine how it actually happens at the code level! Below, you can see an example of token minting.</p> <p></p> <p>After the collection ID correctness check, we\u2019re prompted to send a transaction. In order to do that, we have to pass a Metadata URI, which, again, is a JSON with properties that we\u2019ll store on IPFS.</p> <p></p> <p>If you\u2019ve passed the correct information, you should see the following screen:</p> <p></p> <p>This means that the NFT was successfully created \ud83c\udfdd.</p> <p>How to see an NFT\u2019s content</p> <p>After the NFT creation, we can check what it contains using the Rarible API with the <code>getItemById</code> endpoint. An exemplary API call looks like this:</p> <p>https://api-staging.rarible.org/v0.1/items/SOLANA:2oLE3AJiNGiB96ncXCMb8JsMLpX2uHfdcoMDFNEM7BVg</p> <p>As a response, we can see all the details of the NFT:</p> <pre><code>{\n   \"id\":\"SOLANA:2oLE3AJiNGiB96ncXCMb8JsMLpX2uHfdcoMDFNEM7BVg\",\n   \"blockchain\":\"SOLANA\",\n   \"collection\":\"SOLANA:FqGt8QaZ85hVF7nHWUYyFRhJR186vie7yKuxjXX2pzQS\",\n   \"creators\":[\n      {\n         \"account\":\"SOLANA:A4t9PGWWUwwRhpEh3B9AL8uphgwiNZPBmx2H5RwrXuD9\",\n         \"value\":10000\n      }\n   ],\n   \"lazySupply\":\"0\",\n   \"pending\":[\n\n   ],\n   \"mintedAt\":\"2022\u201305\u201309T16:17:56Z\",\n   \"lastUpdatedAt\":\"2022\u201305\u201309T16:17:56Z\",\n   \"supply\":\"1\",\n   \"meta\":{\n      \"name\":\"Konosuba Characters\",\n      \"description\":\"test collection\",\n      \"attributes\":[\n\n      ],\n      \"content\":[\n         {\n            \"@type\":\"IMAGE\",\n            \"url\":\"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\",\n            \"representation\":\"ORIGINAL\",\n            \"mimeType\":\"image/jpeg\",\n            \"size\":69036,\n            \"width\":352,\n            \"height\":500\n         }\n      ],\n      \"restrictions\":[\n\n      ]\n   },\n   \"deleted\":false,\n   \"auctions\":[\n\n   ],\n   \"totalStock\":\"0\",\n   \"sellers\":0\n}\n</code></pre> <p>And voila. Freshly minted NFT on Solana ready to trade, hold, or whatever you want to do with that.</p>"},{"location":"getting-started/solana-nft-app/#summary","title":"Summary","text":"<p>In this article, we\u2019ve learned how you can take advantage of the Rarible SDK and API to create and see an NFT on Solana. The most important thing to remember while developing is to set your Phantom network to devnet, and the environment to \u201cdevelopment\u201d on Rarible SDK. If you remember that, everything else should flow as smooth as butter. \ud83e\uddc8</p>"},{"location":"getting-started/tezos-blockchain-tutorial/","title":"How to create NFTs on Tezos Blockchain using Rarible Protocol?","text":"<p>What is Tezos blockchain, and how can you create NFTs on it? Main properties of Tezos are:</p> <ol> <li> <p>Self-Amendment</p> <p>In pursuit of a strong, united community, without the need for hard forks, they\u2019ve created a self-amendment algorithm that basically adapts proposed changes step by step (of course, only the ones accepted by the community). The algorithm is very strong, error-resistant and what there are currently a lot of different proposals for improvements.</p> </li> <li> <p>Proof Of Stake</p> <p>It is always nice to have a proof of stake mechanism: faster transactions, insanely low fees compared to PoW chains like Ethereum.</p> </li> <li> <p>Smart Contracts</p> <p>Tezos native smart contract\u2019s language is Michelson, which facilitates formal verification.</p> </li> </ol> <p>As you can see, Tezos is a pretty stable option.</p>"},{"location":"getting-started/tezos-blockchain-tutorial/#how-to-get-funds-in-tezos-test-wallet","title":"How to get funds in Tezos test wallet","text":"<p>Before we can mint an NFT, we actually need to have some sort of asset to spend. We use \u201cfaucets\u201d for that. A Faucet is basically a software that can pour some crypto into your test account. You can find detailed instructions on how to do it here.</p>"},{"location":"getting-started/tezos-blockchain-tutorial/#creating-nfts-on-tezos-programmatically","title":"Creating NFTs on Tezos, programmatically","text":"<p>To make everything done as quickly and efficiently as possible, we will use the Rarible Protocol. It allows you to create NFTs on a few blockchains right now, and one of them is Tezos (it also makes it very simple to do so). You can change your codebase from creating NFTs on Ethereum to Tezos in basically two lines.</p> <p>On Rarible, we\u2019ve created a ready-to-code template, with Next JS, Tailwind CSS, and already configured Rarible SDK, which you can just clone from GitHub and follow along. Since the code of the Union SDK (the one which is already set for you) is pretty complicated, we won\u2019t dive into it in this article.</p>"},{"location":"getting-started/tezos-blockchain-tutorial/#app-file","title":"App file","text":"<p>We start by wrapping the whole app in <code>SdkWalletConnecter</code> and <code>SdkContextProvider</code>. Additionally, we pick the desired wallet that we want to use in our project. Beacon is a provider that allows us to use Temple Wallet, which supports Tezos. \ud83d\udca1</p> <p></p> <p>If you want to change the appearance of the \u201cconnect wallet\u201d button, you can do it in <code>sdk-wallet-connector.tsx</code>, specifically using the Options function.</p>"},{"location":"getting-started/tezos-blockchain-tutorial/#index-file","title":"Index File","text":"<p>The Index File is responsible for creating the view shown above.</p>"},{"location":"getting-started/tezos-blockchain-tutorial/#pass-collection-id","title":"Pass Collection ID","text":"<p>Collection ID is in a format called the \u201cUnion Address\u201d. The Union Address is nothing more than the blockchain name in uppercase letters, followed by colon, followed by contract address. On most blockchain smart contracts there are accounts, just like any other, but with a few differences. They contain executable code. \ud83d\udc68\u200d\ud83d\udcbb</p> <p>Examples of correct Union Addresses:</p> <p>ETHEREUM: 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82</p> <p>TEZOS: KT18vSGouhJcJZDDgrbBKkdCBjSXJWSbui3i</p> <p>When it comes to Rarible\u2019s smart contract addresses, you can find most of them here.</p> <p>Unfortunately, some of them (e.g. Flow, Tezos) can change due to continuous development, so the best place to find the right one is on discord (Rarible Protocol). Just ping us there. \ud83d\ude09</p> <p>For Tezos, the address of the smart contract on Hangzhounet\u2019s test network is:</p> <p>KT18vSGouhJcJZDDgrbBKkdCBjSXJWSbui3i</p> <p>And you can see your test Tezos token by going to https://rinkeby.rarible.com/ and selecting the Tezos blockchain on the explore dropdown.</p> <p></p>"},{"location":"getting-started/tezos-blockchain-tutorial/#pass-additional-parameters","title":"Pass Additional Parameters","text":"<p>We use collection ID in order to determine a few things:</p> <ul> <li>If Union Address is correct</li> <li>If Lazy Mint is supported</li> <li>If Multiple Supply is allowed</li> </ul> <p>You can look through the response object to see all the properties.</p> <p></p>"},{"location":"getting-started/tezos-blockchain-tutorial/#submitting-response-object-to-the-blockchain","title":"Submitting Response Object to the Blockchain","text":"<p>After filling in all the wanted properties, it\u2019s time to submit the transaction.</p> <p></p> <p></p>"},{"location":"getting-started/tezos-blockchain-tutorial/#summary","title":"Summary","text":"<p>And that\u2019s it! It\u2019s really simple, to be honest. Now let\u2019s take a look at what we have learned:</p> <ul> <li>What Tezos is and what is special about it.</li> <li>Where to find the ready-to-code GitHub template.</li> <li>How to create an NFT on Tezos blockchain.</li> </ul>"},{"location":"getting-started/unifiedTransfer/","title":"Transfering token between two addresses","text":"<p>Process of transfering tokens between two addresses is straightforward. In order for the transfer to be successful it has to be created from an address to which an NFT belongs to. Signing of the transaction by the owner will also be required.</p> <p>Basically what we need is two things:</p> <ul> <li>itemId: which allows to uniquely identify any NFT on any blockchain,</li> <li>recipientAddress: which tells us where the token should be transfered.</li> </ul>"},{"location":"getting-started/unifiedTransfer/#create-an-itemid-preparetransferrequest","title":"Create an ItemId &amp; PrepareTransferRequest","text":"<p>Item Id, as a lot of addresses in Rarible Protocol, consist of a few parts, separated by colon sign - ':'.</p> <p>We can create Item Id by merging:</p> <ol> <li>Blockchain name - ETHEREUM, TEZOS, FLOW, etc.,</li> <li>Contract address - address of a smart contract responsible for NFT creation (you can find a smart contract address for specific blockchain here),</li> <li>Token Id - id of minted / lazy minted token.</li> </ol> <p>So the ItemId, in theory, will look like that: {BLOCKCHAIN_NAME}:{CONTRACT_ADDRESS}:{TOKEN_ID}</p> <p>while in practice it can look like that:</p> <pre><code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070;\n</code></pre> <p>On the other hand we have a PrepareTransferRequest which is a simple object of PrepareTransferRequest type with an itemId property.</p> <p>In code you can do it like that:</p> <pre><code>// Imports\n// unionAddress will be used and explained further in the article\nimport { toItemId, toUnionAddress } from \"@rarible/types\";\n\nconst itemId =\n  \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070\";\n\nconst transferRequest: PrepareTransferRequest = {\n  itemId: toItemId(itemId),\n};\n</code></pre>"},{"location":"getting-started/unifiedTransfer/#call-sdknfttransfer-method-with-transferrequest-as-an-argument","title":"Call sdk.nft.transfer method with transferRequest as an argument","text":"<p>In the next step we take PrepareTransferRequest that we've created in previous step and use it to call sdk.nft.transfer method. It will return us a submit function as well as available options for that operation.</p> <pre><code>const transferResponse = await sdk.nft.transfer(transferRequest);\n\n// Example of a response\n// {\n//     \"multiple\": false,\n//     \"maxAmount\": \"1\",\n//     \"submit\": f()\n// }\n</code></pre>"},{"location":"getting-started/unifiedTransfer/#call-a-submit-function","title":"Call a submit function","text":"<p>Now, there is one thing left and it is to call a submit function we previously fetched. This is the step which will trigger a Metamask window and a payment, since we're doing write operation on a blockchain (changing an owner is a write operation).</p> <p>Submit object consist of two parameters:</p> <ul> <li>to (required) - which is of type of UnifiedAddress {BLOCKCHAIN_NAME}:{ADDRESS},</li> <li>amount - if the multiple flag from the previous step was true, it's possible to transfer more than one NFT, default to one.</li> </ul> <pre><code>const response = await transferResponse.submit({\n  to: toUnionAddress(\"ETHEREUM:0x18c37f21D3C29f9a53A96CA678026DC660180065\"),\n  amount: 1,\n});\n\n// Example of a response\n// {\n//     \"transaction\": {\n//         \"receipt\": {},\n//         \"hash\": \"0xe78cb6963ac4c960c5c623d08d1407a\",\n//         \"data\": \"0x832fbb2...\",\n//         \"nonce\": 24,\n//         \"from\": \"0x79ea2d536b5b7144a3eabdc6a7e43130199291c0\",\n//         \"to\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\"\n//     },\n//     \"network\": \"rinkeby\",\n//     \"blockchain\": \"ETHEREUM\"\n// }\n</code></pre> <p>That's all in this section.</p>"},{"location":"overview/architecture/","title":"Architecture","text":"<p>Rarible Multichain protocol is built on 3-layer architecture:</p> <ul> <li>Blockchain Indexing Layer \u2013 a set of listeners to retrieve blockchain events process them and store in Rarible Database in a form of business objects</li> <li>Smart-Contracts \u2013 provide common logic to operate NFT-assets, e.g., minting, selling, transferring, auctions, etc.</li> <li>Multichain API \u2013 SDK for developers to use protocol capabilities in a simple blockchain-agnostic manner</li> </ul> <p> </p> Protocol architecture <p>The Protocol is primarily targeted to NFTs, but it's not limited to NFTs only. Any asset on EVM blockchain can be traded on Rarible.</p> <p>Rarible doing indexing per each blockchain integrated into protocol. Following events are listened:</p> <ul> <li>Block events</li> <li>Log events</li> </ul> <p>Rarible Multichain Protocol is fast performing and able to retrieve blocks with up to 2 seconds delay from blockchain. Blockchain restructuring is supported \u2013 changed blocks are indexed again to resolve discrepancies if any.</p> <p>Likewise, blockchain indexing Rarible protocol listens for most popular NFT-marketplaces to retrieve their order books, this helps to store in Rarible database both on-chain and off-chain information.</p> <p>Smart-contracts are constructed in the way to be upgradeable, orders have versioning information, so new fields can be added if needed in the future.</p> <p>All smart-contracts in Rarible before publishing pass mandatory security audit, so only verified reliable versions are provided with protocol.</p> <p>Multichain API provides blockchain agnostic SDK to:</p> <ul> <li>Search and retrieve business objects from Rarible Database (NFTs, orders, collections and detailed information about these objects)</li> <li>Perform on-chain actions \u2013 mint, sell, transfer NFTs</li> <li>Perform off-chain activities like lazy-minting</li> <li>Apply royalties and organize auctions</li> </ul> <p>In addition, Rarible Multichain Protocol provides information for dedicated customers to retrieve information about business objects changed immediately     in publish-subscribe manner using Apache Kafka feed. Indexed events are sent to Apache Kafka in the same time they are stored in the database.</p>"},{"location":"overview/auctions/","title":"Auctions","text":""},{"location":"overview/auctions/#auctions-types","title":"Auctions types","text":"<p>In Rarible Protocol implements English auction with fixed step. We have two AuctionHouse contracts for different type of sell asset. At that moment, we support English auction only for Ethereum and Polygon blockchains.</p> <p>AuctionHouse contracts types:</p> <ul> <li><code>AuctionHouse721</code><ul> <li>sell asset = ERC-721</li> <li>buy asset = ETH or ERC-20</li> <li>supports party bid</li> </ul> </li> <li><code>AuctionHouse1155</code><ul> <li>sell asset = ERC-1155</li> <li>buy asset = ETH or ERC-20</li> </ul> </li> </ul>"},{"location":"overview/auctions/#features","title":"Features","text":"<p>There are two parameters of AuctionHouse that are the same for all auctions and can be changed by AuctionHouse owner:</p> <ul> <li><code>minimalDuration</code> \u2014 defines the minimal duration of auctions</li> <li><code>minimalStepBasePoint</code> \u2014 is the minimal percentage increase between bids (in base points). For example, <code>minimalStepBasePoint</code> = 300 = 3%, first bid is 100 ETH, the second one should be not less than (100 + 100*3% =) 103</li> </ul> <p>Auction time frame is decided by 2 parameters:</p> <ul> <li><code>duration</code><ul> <li>mandatory parameter, that defines the duration of auction in seconds</li> <li>it must be between <code>minimalDuration</code>(default value is 15 days) and <code>1000 days</code> (constant)</li> </ul> </li> <li><code>startTime</code><ul> <li>optional parameter that defines the start time an auction</li> <li>unix timestamp, can't be less than the time of creation of the auction</li> </ul> </li> </ul> <p>So there are two cases of how the auction time frame can work:</p> <ul> <li>if <code>startTime</code> is 0, then the auction starts at the first bid that satisfies <code>minimalPrice</code>. Then the <code>endTime</code> is calculated at the moment of the first bid as well (<code>now</code> + <code>duration</code>)</li> <li>if <code>startTime</code> is set, then the <code>endTime</code> is calculated at the creation of an auction (<code>startTime</code> + <code>duration</code>)</li> </ul> <p>If a new bid is put when auction has less than <code>minimalDuration</code> left till <code>endTime</code>, then <code>endTime</code> = <code>now</code> + <code>minimalDuration</code></p>"},{"location":"overview/auctions/#data-model","title":"Data model","text":""},{"location":"overview/auctions/#auction-erc721","title":"Auction ERC721","text":"<ul> <li>address sellToken \u2014 sell asset contract address</li> <li>uint sellTokenId \u2014 sell asset tokenId</li> <li>address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH)</li> <li>uint96 endTime \u2014 auction end time in unix timestamp</li> <li>Bid lastBid \u2014 last successful <code>Bid</code></li> <li>address payable seller \u2014 seller address</li> <li>uint96 minimalPrice \u2014 minimal amount of the first bid</li> <li>address payable buyer \u2014 last successful bidder</li> <li>uint64 protocolFee \u2014 protocolFee at the time of auction creation</li> <li>bytes4 dataType \u2014 version of <code>data</code> field</li> <li>bytes data \u2014 encoded additional data, V1 fields<ul> <li>uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient)</li> <li>uint duration \u2014 auction duration</li> <li>uint startTime \u2014 auction start time</li> <li>uint buyOutPrice \u2014 auction buyOut price (if bid amout &gt; buyout price, then auction finishes and all transfers are done)</li> </ul> </li> </ul>"},{"location":"overview/auctions/#auctionerc1155","title":"AuctionERC1155","text":"<p>The main difference from struct Auction ERC721 is the additional field uint96 sellTokenValue</p> <ul> <li>address sellToken \u2014 sell asset contract address</li> <li>uint96 sellTokenValue \u2014 sell asset value</li> <li>uint sellTokenId \u2014 sell asset tokenId</li> <li>address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH)</li> <li>uint96 endTime \u2014 auction end time in unix timestamp</li> <li>Bid lastBid \u2014 last successful <code>Bid</code></li> <li>address payable seller \u2014 seller address</li> <li>uint96 minimalPrice \u2014 minimal amount of the first bid</li> <li>address payable buyer \u2014 last successful bidder</li> <li>uint64 protocolFee \u2014 protocolFee at the time of auction creation</li> <li>bytes4 dataType \u2014 version of <code>data</code> field</li> <li>bytes data \u2014 encoded additional data, V1 fields<ul> <li>uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient)</li> <li>uint duration \u2014 auction duration</li> <li>uint startTime \u2014 auction start time</li> <li>uint buyOutPrice \u2014 auction buyOut price (if bid amout &gt;= buyout price, then auction finishes and all transfers are done)</li> </ul> </li> </ul>"},{"location":"overview/auctions/#bid","title":"Bid","text":"<ul> <li>amount \u2014 <code>bid</code> amount</li> <li>dataType \u2014 version of <code>data</code> field</li> <li>data \u2014 encoded additional data, V1 fields<ul> <li>uint originFee \u2014 bid origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient)</li> </ul> </li> </ul>"},{"location":"overview/auctions/#main-functions","title":"Main functions","text":"<p>startAuction</p> <ul> <li>start new auction</li> <li>emits event <code>AuctionCreated(uint indexed auctionId, address seller, uint128 endTime)</code></li> <li>can be called from anyone</li> <li>arguments for ERC721 Auction<ul> <li>address _sellToken \u2014 sell token address</li> <li>uint _sellTokenId \u2014 sell token Id</li> <li>address _buyAsset \u2014 buy asset address (0 if ETH)</li> <li>uint96 minimalPrice \u2014 minimal first bid price</li> <li>bytes4 dataType \u2014 data field type</li> <li>bytes memory data \u2014 additional Data</li> </ul> </li> <li>arguments for ERC1155 Auction (1 additional field uint96 _sellTokenValue)<ul> <li>address _sellToken \u2014 sell token address</li> <li>uint96 _sellTokenValue \u2014 sell token value</li> <li>uint _sellTokenId \u2014 sell token Id</li> <li>address _buyAsset \u2014 buy asset address (0 if ETH)</li> <li>uint96 minimalPrice \u2014 minimal first bid price</li> <li>bytes4 dataType \u2014 data field type</li> <li>bytes memory data \u2014 additional Data</li> </ul> </li> </ul> <p>putBid</p> <ul> <li>puts bid on specific auction</li> <li>emits event <code>BidPlaced(uint indexed auctionId, address seller, uint128 endTime)</code></li> <li>can be called from anyone</li> <li>arguments:<ul> <li>_auctionId \u2014 auction Id</li> <li>bid \u2014 bid struct</li> </ul> </li> </ul> <p>finishAuction</p> <ul> <li>finishes auction if it's ended(now &gt; endTime) and has at least 1 bid</li> <li>emits event <code>AuctionFinished(_auctionId)</code></li> <li>can be called from anyone</li> <li>arguments:<ul> <li>_auctionId \u2014 auction Id</li> </ul> </li> </ul> <p>buyOut</p> <ul> <li>buy out the sell item and finishes the auction</li> <li>emits event <code>AuctionBuyOut(uint indexed auctionId, address buyer)</code></li> <li>emits event <code>AuctionFinished(_auctionId)</code></li> <li>can be called from anyone</li> <li>arguments:<ul> <li>_auctionId \u2014 auction Id</li> <li>bid \u2014 bid struct</li> </ul> </li> </ul> <p>cancel</p> <ul> <li>finishes auction if it's not started and has no bids</li> <li>emits event <code>AuctionCancelled(uint indexed auctionId)</code></li> <li>emits event <code>AuctionFinished(_auctionId)</code></li> <li>can be called from auction creator</li> <li>arguments:<ul> <li>_auctionId \u2014 auction Id</li> </ul> </li> </ul>"},{"location":"overview/data-model/","title":"Protocol Data Model","text":"<p>Rarible Protocol uses the following basic concepts to form the Data Model:</p> <ul> <li><code>item</code> \u2014 NFT (Non-Fungible Token)</li> <li><code>collection</code> \u2014 collection of NFT items</li> <li><code>blockchain</code> \u2014 name of the blockchain network</li> <li><code>order</code> \u2014 intent to sell an NFT</li> <li><code>activity</code> \u2014 events with items like \"MINT\", \"SELL\" etc.</li> </ul> <p>Collections and items have their own <code>id</code>, that contain the <code>blockchain</code> and different types of <code>tokens</code>.</p> <p></p>"},{"location":"overview/data-model/#item","title":"Item","text":"<p>The <code>item</code> has an array of required and optional parameters. It depends on several parameters and contains the name of the <code>blockchain</code>, address or <code>token</code> of the item <code>collection</code>.</p> <p></p>"},{"location":"overview/data-model/#collection","title":"Collection","text":"<p>The <code>collection</code> has an array of required and optional parameters too. It depends on several parameters and contains the name of the <code>blockchain</code> and <code>tokens</code> of the <code>collection</code>.</p> <p></p>"},{"location":"overview/data-model/#order","title":"Order","text":"<p>Order means intent to sell an NFT for a given price. To complete the Order, accept the Bid from the potential buyer.</p> <p></p> <p>The <code>order</code> has an array of required and optional parameters. It depends on several parameters and contains the name of the <code>blockchain</code> too.</p> <p></p> <p>You can find more information and examples on Search Capabilities page.</p>"},{"location":"overview/indexer/","title":"Indexer","text":"<p>It's nice to think that every service in the crypto space is fully decentralized. Of course, it isn't. Just imagine looking through the Ethereum blockchain for specific information.</p> <p>Right now, i.e. 23.03.2022 the Ethereum blockchain size is almost 1 TB. It would be impossible to traverse that big chunk of a data in UX-friendly timeframe. That's why indexers originated. At the end of the day, what does indexing mean? It means to write data somewhere for later usage.</p> <p>In its essence, indexer take the data which we're interested in from blockchain (most of the time, we're not interested in every specific transaction, just the ones connected to our dApp), and saves it in some sort of database. It can be SQL or NoSQL \u2014 it doesn't really matter. What matters is that now, we have some sort of structure, which we can travel fast and efficiently.</p>"},{"location":"overview/indexer/#rarible-multichain-indexer","title":"Rarible Multichain Indexer","text":"<p>Now, when we're conscious about indexer responsibilities and duty, we can lean over what types of indexers are used in Rarible.</p> <p>On Rarible, we have three different types of indexers:</p> <ul> <li>NFT Indexer</li> <li>Token/Balance-Indexer</li> <li>Order Indexer</li> </ul> <p>Additionally, in order for the services to work, we have a MongoDB instance, where all the indexed data from different blockchains sits, and a Multichain SDK API which allows for data traversing.</p>"},{"location":"overview/indexer/#nft-indexer","title":"NFT Indexer","text":"<p>NFT Indexer is used to index all history of NFTs related actions, i.e. mint, transfer and burn. Indexer gets logs from an Ethereum network, and accordingly creates NFT items in a NoSQL database. Especially, it listens to a change of a state of an NFT item ownership.</p>"},{"location":"overview/indexer/#tokenbalance-indexer","title":"Token/Balance-Indexer","text":"<p>Token/Balance-Indexer is responsible for tracking user balances. If we mapped it to the Rarible usage, it checks if a user has enough of a given currency to make a bid. It handles all the information about a user's wallet status.</p>"},{"location":"overview/indexer/#order-indexer","title":"Order Indexer","text":"<p>In order to properly display order information (order means intent, e.g. intent to sell, or in simpler words, intent to sell an NFT for a given price), we need an order price in addition to other properties. That's where Order Indexer comes in.</p> <p>Listener catches logs which say e.g. if an order was executed, and what is the status of an order. It fetches order data from a few different places like OpenSea, Rarible OrderBook, or Cryptopunks.</p>"},{"location":"overview/indexer/#how-does-the-indexer-gather-the-data","title":"How does the indexer gather the data?","text":"<p>It listens for specific events on a blockchain. Since every transaction and movement on a blockchain is emitted in a form of logs, and every log has its unique topic id, it can be explicitly identified.</p> <p>Moreover, the indexer is also listening for block creation events. Listening from two sources simultaneously gives us the certainty that we will manage to catch all events we're interested in.</p>"},{"location":"overview/indexer/#what-events-do-the-indexer-listen-to","title":"What events do the indexer listen to?","text":"<p>Indexer listens mainly for transfer-type events. That's because almost all the NFT-related actions, including Minting, involve a transfer method, which creates an NFT (in that scenario we transfer the NFT from 0x0 address to the address of a creator).</p> <p>From fetched logs, the indexer creates item and ownership objects that it stores in a database. It also tracks events for a specific collection (Rarible collection, etc.) from which it creates a token entity, and stores it in a database as well.</p>"},{"location":"overview/indexer/#multichain-abstraction","title":"Multichain abstraction","text":"<p>In order to be able to connect differently, not EVM based blockchains together, Rarible had to create a few different blockchain indexers. They all work based on the same principle, but since different blockchains like Tezos, Solana, Flow, have different architecture, they couldn't be simply merge.</p> <p>But the merge could be abstracted, and that's what Rarible has done. It created a service called Union, and it works as a \"really smart proxy\" which allows you to use one API for all the blockchains. It takes all the Kafka proxy topics, from all the blockchains, and merges it into one topic. That's how you're able to get info from all the blockchains by using one Multichain API.</p>"},{"location":"overview/lazy-minting/","title":"Lazy Minting","text":"<p>In order to be able to fully understand what lazy minting is, and the benefits of doing so, we have to scratch the other aspects of blockchain and NFTs first. This document will touch three main aspects, which are crucial in a lazy minting process understanding:</p> <ol> <li>Technical description of NFT</li> <li>Minting</li> <li>Lazy Minting</li> </ol> <p></p>"},{"location":"overview/lazy-minting/#technical-description-of-nft","title":"Technical description of NFT","text":"<p>If you're familiar with the concept of NFTs creation, feel free to skip this section.</p> <p>NFT in its essence is just a variable in a Smart Contract code. The most common approach is as follows:</p> <ol> <li> <p>Upload metadata (image, description, attributes, etc.) to IPFS, which is a decentralized JSON-like database. If you ever used a NoSQL database like MongoDB or Firebase, that's basically that, only decentralized.</p> <p>Based on all the properties you've uploaded, a hash is calculated, by which you can now access your asset. Professionally, it's called URI, which stands for Unique Resource Identifier. Moreover, since storing image data on the blockchain would be expensive, instead of image data itself, you store an image URL in your NFT.</p> <p>The image itself can be stored on IPFS. Just not in the JSON you use for the NFT creation.</p> </li> <li> <p>Invoke a Smart Contract function responsible for minting, and assign the URI created in the earlier step to your account address.</p> <p>That's it. Since the code on the blockchain is immutable, and we have a tokenId variable that tracks every unique NFT creation on a given smart contract, even if the same URI would be used twice, it will still be a different NFT.</p> </li> </ol>"},{"location":"overview/lazy-minting/#minting","title":"Minting","text":"<p>If you've read the first point, you've already had a quite good explanation of how the minting process works.</p> <p>Minting can be described as a process of a write operation (it's an important fact, because if you're writing on the blockchain, you're paying a gas fee), which has one goal \u2014 associate an address of a creator with a tokenId, which points to token metadata URI on IPFS. Pardon those who thought that it is more complicated.</p> <p>Of course, there are some language-specific restrictions and security steps that we have to take care of, but it's enough to use OpenZeppelin implementation of ERC721/ERC1155 to safely elevate core functionality, which in this case is NFT creation.</p>"},{"location":"overview/lazy-minting/#lazy-minting_1","title":"Lazy Minting","text":"<p>The most important difference to point out between minting and lazy minting is writing to the blockchain action. As it was said before when writing to a blockchain occurs, the money from your wallet disappears i.e. you pay a gas fee.</p> <p>In a normal minting, this process takes place immediately. In a lazy mint, it can be postponed to the first transfer action (mostly it will be a buy action).</p> <p>How does that work under hood? There is some sort of off-chain database involved there. Basically, instead of immediately minting an NFT, the service stores its details in the off-chain database. In this way, it is able to properly display all the information like image, creator, etc.</p> <p>When the first buy occurs, it is then minted straight to the buyer, but keeps all the information about an author or royalties. The benefits of that are obvious \u2014 you as the creator don't pay a gas limit. You get the same functionality without any cost.</p> <p>You can then either lower the price of an NFT since the duty of gas payment lies on the buyer's side, or you can just get more money. The choice is yours.</p>"},{"location":"overview/next-steps/","title":"Next Steps","text":"<p>The main information about starting using Rarible Protocol Multichain SDK</p> <ul> <li>Quick Start Guide</li> <li>Reference Overview</li> <li>Contract Addresses</li> <li>Install and configurate SDK</li> <li>Wallets initialization</li> <li>Use Cases</li> </ul>"},{"location":"overview/protocol-overview/","title":"Protocol Overview","text":"<p>Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK.</p> <p>Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page.</p> <p>We use different environments for blockchain networks. See actual information on API Reference page.</p> <p>Rarible Multichain SDK enables applications to easily interact with Rarible Protocol: query, issue and trade NFTs on any blockchain supported. See more information on Reference section.</p> <p>Know about NFTs</p> <p>Rarible Multichain Protocol indexes and provides via API wide information about NFTs. The following data is accessible for developer using protocol near real time it is put into blockchain:</p> <ul> <li>Basic NFT information</li> <li>Owner</li> <li>Creator</li> <li>Metadata</li> <li>NFT transactions</li> </ul> <p>In addition to on-chain information, Rarible Multichain Protocol collects of-chain information like:</p> <ul> <li>Orders put for selling</li> <li>Bids put on NFTs</li> <li>Auctions information</li> </ul> <p>Multiple blockchains support</p> <p>Rarible Multichain Protocol is completely blockchain agnostic. Developers do not have to know details about a specific blockchain and can easily start with any of blockchains currently supported (see full list on Features page).</p> <p>Decrease entrance level for developer</p> <p>Rarible Multichain protocol provides easy-to-use API that can be used with:</p> <ul> <li>Frontend application</li> <li>Backend server application</li> <li>Mobile app on IOS/Android/Huawei platform</li> </ul> <p>No specific knowledge needed to start working with Rarible Multichain Protocol.</p> <p>Reliability and Performance</p> <p>Rarible Multichain Protocol provides high performance and reliable tools for developers. Smart-contracts for Rarible Multichain Protocol pass security audit before publishing. We are indexing data with small delay between it appear on a blockchain and moment when it is accessible with Protocol API, for most performant blockchains we sync data with up to 2 seconds delay from origin.</p> <p>Low Gas Consumption</p> <p>Rarible Multichain Protocol focused on optimizing usage costs for the users. For blockchains like Ethereum, where gas price is sufficient, we are doing a lot to minimize gas usage:</p> <ul> <li>Storing a considerable amount of up-to-date data off-chain - developers using our API to fetch NFT information do not pay the gas fee</li> <li>Providing Lazy-mint functionality that does not cost gas for minter</li> <li>Continuous smart contracts review and update, including on-chain auctions</li> </ul> <p>Advanced and robust tech done for you</p> <p>Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years, with wide functionality and data on all the NFTs created.</p> <p>Monetization</p> <p>Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.</p>"},{"location":"overview/protocol-status/","title":"Protocol Status Page","text":"<p>Available in Q2 2022</p>"},{"location":"overview/tokens-fees-royalties/","title":"Tokens, Fees, and Royalties","text":""},{"location":"overview/tokens-fees-royalties/#what-is-nft","title":"What is NFT","text":"<p>NFT means Non-Fungible Token. \u201cNon-fungible\u201d more or less means that it\u2019s unique and can\u2019t be replaced with something else. For example, a bitcoin is fungible \u2014 trade one for another bitcoin, and you\u2019ll have exactly the same thing.</p> <p>NFTs on the other hand are one-of-a-kind tokens that represent a unique good or asset which are non-fungible. If you traded it for a different NFT, you\u2019d have something completely different.</p> <p>NFTs can really be anything digital (such as drawings, music, videos, etc.), but a lot of the current excitement is around using the tech to sell digital art.</p>"},{"location":"overview/tokens-fees-royalties/#tokens","title":"Tokens","text":"<p>Rarible Multichain Protocol various token types applicable for certain blockchain:</p> <ul> <li> <p>Ethereum/Polygon:</p> <ul> <li>ERC-721</li> <li>ERC-1155</li> <li>Rarible user-owned contracts (ERC-721 and ERC-1155) \u2014 users deploy these contracts, only owners can mint in these</li> <li>Immutablex</li> <li>ERC-721</li> <li>Flow standard tokens</li> <li>FA2 (TZIP-012) for Tezos</li> <li>Cryptopunks</li> </ul> </li> </ul> <p>A full list of supported token types could be found on Features page.</p> <p>All these contracts support these features:</p> <ul> <li>lazy mint</li> <li>Rarible on-chain royalties</li> <li>multiple creators</li> <li>upgradeable</li> <li>supports operators (who can transfer tokens on behalf of users) for the whole smart contract</li> </ul> <p>User-owned contracts use beacon proxies, and these contracts can be updated by Rarible DAO. Rarible common contracts can be upgraded too.</p>"},{"location":"overview/tokens-fees-royalties/#fees","title":"Fees","text":"<p>Rarible Multichain Protocol supports the following types of fees that are applicable to token operations:</p> <ul> <li>Protocol fees \u2014 are charged on both sides of the transaction</li> <li>Origin fees \u2014 set for each order. It may differ for two orders</li> <li>Royalties \u2014 the author of the work will receive a part of each sale</li> </ul> <p>Here is an example, how do we calculate fees for Ethereum for each side of the transaction:</p> <p> </p> <ul> <li>If there is ETH on any side of the transaction, it is used</li> <li>If there is no ETH, we check if there is an ERC-20 and use it</li> <li>If there is no ERC-20, check if there is an ERC-1155 and use it</li> <li>Otherwise, no fee will be charged. (e.g., if two ERC-721 are involved in the transaction)</li> </ul> <p>When computing the total amount of the asset:</p> <ul> <li>The protocol fee is added on top of the filled amount</li> <li>The fee for sending the buyer's order is also added on top</li> </ul> <p>If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens.</p> <p>If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction.</p>"},{"location":"overview/tokens-fees-royalties/#royalties","title":"Royalties","text":"<p>Rarible Multichain Protocol supports two types of royalties:</p> <ul> <li>RoyaltiesV1 \u2014 defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts.</li> <li>RoyaltiesV2 \u2014 the exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry. The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array.</li> <li>EIP-2981 \u2014 allows contracts, such as NFTs that support ERC-721 and ERC-1155 interfaces, to signal a royalty amount to be paid to the NFT creator or rights holder every time the NFT is sold or re-sold. This is intended for NFT marketplaces that want to support the ongoing funding of artists and other NFT creators.</li> </ul> <p>For RoyaltiesV1, contract exposes <code>getRoyalties</code> method, which expects an ID as input (usually tokenId) and returns an array of accounts &amp; basis points.</p> <p>RoyaltiesV2 allows for Rarible to support different royalty standards for different collections.</p> <p>Rarible Multichain Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function.</p> <p>This tuple is made up of two variables, <code>fees.recipient</code> and <code>fees.value</code>:</p> <ul> <li><code>fees.recipient</code> \u2014 refers to either the item owner (by default) or an address where the royalties will be received.</li> <li><code>fees.value</code> \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here.</li> </ul>"},{"location":"reference/bid/","title":"Create and Accept Bid","text":"<p>You can Create and Accept Bids with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/bid/#create-a-bid","title":"Create a bid","text":"<p>You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not.</p> <p>Use <code>bid</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { RequestCurrency } from \"@rarible/sdk/build/common/domain\"\n\nasync function bid(wallet: BlockchainWallet, assetType: RequestCurrency) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const bidAction = await sdk.order.bid({\n        itemId: toItemId(\"&lt;ITEM_ID&gt;\"),\n    })\n    const bidOrderId = await bidAction.submit({\n        amount: 1,\n        price: \"0.000002\",\n        currency: assetType,\n    })\n    return bidOrderId\n}\n</code></pre> <ul> <li><code>itemId</code> \u2014  Id of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code>. For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></li> <li><code>amount</code> \u2014 amount of NFT tokens </li> <li><code>price</code> \u2014 price per 1 NFT in ETH</li> <li><code>currency</code> \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.)</li> </ul>"},{"location":"reference/bid/#bid-on-collection","title":"Bid on collection","text":"<p>For create bid on collection, use <code>bidOnCollection</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toContractAddress, toItemId } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { RequestCurrency } from \"@rarible/sdk/build/common/domain\"\n\n//Available only for ethereum\nasync function bidOnCollection(wallet: BlockchainWallet, assetType: RequestCurrency) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const bidAction = await sdk.order.bid({\n        collectionId: toContractAddress(\"&lt;COLLECTION_ADDRESS&gt;\"),\n    })\n    const bidOrderId = await bidAction.submit({\n        amount: 1,\n        price: \"0.000002\",\n        currency: assetType,\n        //+1 hour (optional)\n        expirationDate: new Date(Date.now() + 60 * 60 * 1000),\n    })\n    return bidOrderId\n}\n</code></pre> <ul> <li><code>collectionId</code> \u2014 your collection address, that can be already deployed. Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page</li> <li><code>ContractAddress</code> \u2014 <code>BlockchainName:HexAddress</code> = <code>ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05</code><ul> <li><code>BlockchainName</code> \u2014 <code>ETHEREUM</code>, <code>FLOW</code>, <code>TEZOS</code> or <code>POLYGON</code></li> </ul> </li> </ul>"},{"location":"reference/bid/#update-bid","title":"Update bid","text":"<p>Similarly to updating a sell order, there is also a possibility to update a bid. It can be only higher than the original bid order price.</p> <p>Use <code>bid</code> function with <code>updateAction</code>:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { RequestCurrency } from \"@rarible/sdk/build/common/domain\"\n\nasync function bid(wallet: BlockchainWallet, assetType: RequestCurrency) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const bidAction = await sdk.order.bid({\n        itemId: toItemId(\"&lt;ITEM_ID&gt;\"),\n    })\n    const bidOrderId = await bidAction.submit({\n        amount: 1,\n        price: \"0.000002\",\n        currency: assetType,\n    })\n\n    const updateAction = await sdk.order.bidUpdate({\n        orderId: bidOrderId,\n    })\n    //You can only increase price of bid order for security reasons\n    //If you want to force change bid price you should cancel order\n    await updateAction.submit({ price: \"0.000003\" })\n}\n</code></pre>"},{"location":"reference/bid/#accept-bid","title":"Accept bid","text":"<p>To accept bid, use <code>acceptBid</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toOrderId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\n\nasync function acceptBid(wallet: BlockchainWallet) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const acceptBidResponse = await sdk.order.acceptBid({\n        orderId: toOrderId(\"&lt;BIDDER_ORDER_ID&gt;\"),\n    })\n    const acceptBidResult = await acceptBidResponse.submit({\n        amount: 1,\n        //optional\n        originFees: [{\n            account: toUnionAddress(\"&lt;COMISSION_ADDRESS&gt;\"),\n            //2,5%\n            value: 250,\n        }],\n        //optional\n        payouts: [{\n            account: toUnionAddress(\"&lt;PAYOUT_ADDRESS&gt;\"),\n            //5%\n            value: 500,\n        }],\n        //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ\n        unwrap: false,\n    })\n    await acceptBidResult.wait()\n}\n</code></pre> <ul> <li><code>originFees</code> \u2014 value and address of the origin fees for the order<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the fees. For example, 2,5% value is <code>250</code></li> </ul> </li> <li><code>payouts</code> \u2014 value and address of the payouts for the order<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the payouts. For example, 5% value is <code>500</code></li> </ul> </li> <li><code>unwrap</code> \u2014 convert (true) received WETH/wTEZ tokens to ETH/TEZ or not (false)</li> </ul>"},{"location":"reference/bid/#accept-bid-on-collection","title":"Accept bid on collection","text":"<p>To accept bid on collection, use <code>acceptBidOnCollection</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId, toOrderId } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\n\n//Available only for ethereum\nasync function acceptBidOnCollection(wallet: BlockchainWallet) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const acceptBidAction = await sdk.order.acceptBid({\n        orderId: toOrderId(\"&lt;COLLECTION_ORDER_ID&gt;\"),\n    })\n    //If you have one or more items from collection you should accept one item at the time\n    const acceptBidTx = await acceptBidAction.submit({\n        amount: 1,\n        itemId: toItemId(\"&lt;ACCEPTED_ITEM_ID&gt;\"),\n        //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ\n        unwrap: false,\n    })\n    await acceptBidTx.wait()\n}\n</code></pre>"},{"location":"reference/bid/#cancel-a-bid","title":"Cancel a bid","text":"<p>To cancel a bid, use <code>cancelOrder</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toOrderId } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\n\nasync function cancelOrder(wallet: BlockchainWallet) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const cancelTx = await sdk.order.cancel({\n        orderId: toOrderId(\"&lt;YOUR_ORDER_ID&gt;\"),\n    })\n    await cancelTx.wait()\n}\n</code></pre> <ul> <li><code>orderId</code> \u2014  Id of your order, has format <code>${blockchain}:${id}</code>. For example, <code>ETHEREUM:1234567890</code></li> </ul>"},{"location":"reference/bid/#checking-created-bid","title":"Checking created bid","text":"<p>To check the created bid use the <code>getAuctionBidsById</code> API method</p> getAuctionBidsById <p>Returns Bids by ID.</p> <p><code>https://api.rarible.org/v0.1/auctions/{id}/bids</code></p> <p>Example request (staging)</p> <pre><code>curl --request GET 'https://api-staging.rarible.org/v0.1/orders/bids/byItem?itemId=ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:18821466700545955594683918922933102928122274620066857937800231922729025011855&amp;status=ACTIVE'\n</code></pre> <p>Request parameters:</p> <ul> <li> <p><code>itemId</code> \u2014  ItemID of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code></p> <p>For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></p> </li> </ul> <p>Example response (status 200)</p> <pre><code>{\n    \"orders\": [\n        {\n            \"id\": \"ETHEREUM:0xce5a4beadeddeefdd91dad3092315fbba176dd5325e032dd10194a9bc60bf28c\",\n            \"fill\": \"0\",\n            \"platform\": \"RARIBLE\",\n            \"status\": \"ACTIVE\",\n            \"makeStock\": \"0.12345\",\n            \"cancelled\": false,\n            \"createdAt\": \"2022-03-07T06:46:06.275Z\",\n            \"lastUpdatedAt\": \"2022-03-07T06:46:06.275Z\",\n            \"takePrice\": \"0.12345\",\n            \"takePriceUsd\": \"0.12342413889756425082\",\n            \"priceHistory\": [],\n            \"maker\": \"ETHEREUM:0x45d5ef37dfa2a3cc91d5909fd493f1a480bba6b0\",\n            \"make\": {\n                \"type\": {\n                    \"@type\": \"ERC20\",\n                    \"contract\": \"ETHEREUM:0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea\"\n                },\n                \"value\": \"0.12345\"\n            },\n            \"take\": {\n                \"type\": {\n                    \"@type\": \"ERC721_Lazy\",\n                    \"contract\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n                    \"tokenId\": \"18821466700545955594683918922933102928122274620066857937800231922729025011855\",\n                    \"uri\": \"/ipfs/QmcTxYXrcoHzi5EyoypK6PvCQxy8piZiYpFKjr75MRKp89\",\n                    \"creators\": [\n                        {\n                            \"account\": \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\",\n                            \"value\": 10000\n                        }\n                    ],\n                    \"royalties\": [\n                        {\n                            \"account\": \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\",\n                            \"value\": 1000\n                        }\n                    ],\n                    \"signatures\": [\n                        \"0xee5416f619e2efefbcf4a3cc8645ff61c298ada42a5c9c07e5ce3ed66444a937010daab240392eabad2b8e4bc95f527178c377937c25a655991532a3b2ffa9361c\"\n                    ]\n                },\n                \"value\": \"1\"\n            },\n            \"salt\": \"0x24d4f84a848a4c49df39d73961b887958598046384639c09f61d4dd85f6c5f1e\",\n            \"signature\": \"0x928e0d53da390ea7e58f2d5715d0492ad4dd4cae7a7126759682b642c32e3caf7395edeb8342ebf5fc57d959c996b41079e391565cc00b5966aac7f1788bc2d11c\",\n            \"data\": {\n                \"@type\": \"ETH_RARIBLE_V2\",\n                \"payouts\": [],\n                \"originFees\": [\n                    {\n                        \"account\": \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\",\n                        \"value\": 250\n                    }\n                ]\n            }\n        }\n    ]\n}\n</code></pre> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/burn/","title":"Burn","text":"<p>You can burn NFTs with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/burn/#burn-nfts","title":"Burn NFTs","text":"<p>Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that.</p> <p>Use <code>burn</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\n\nasync function burn(wallet: BlockchainWallet) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n\n    const burnAction = await sdk.nft.burn({\n        itemId: toItemId(\"&lt;ITEM_ID&gt;\"),\n    })\n    const burnTx = await burnAction.submit({\n        amount: 1,\n        //optional\n        creators: [{\n            account: toUnionAddress(\"&lt;CREATOR_ADDRESS&gt;\"),\n            value: 10000,\n        }],\n    })\n    //transaction returned if item is on-chain\n    if (burnTx) {\n        await burnTx.wait()\n    }\n}\n</code></pre> <ul> <li><code>itemId</code> \u2014  Id of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code>. For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></li> <li><code>amount</code> \u2014 amount of NFT tokens</li> <li><code>creators</code> \u2014 value and address of the creator<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the part in the ownership of the item. For example, 100% value is <code>10000</code>. If there are several owners, the total cost cannot be more than <code>10000</code></li> </ul> </li> </ul>"},{"location":"reference/burn/#checking-burned-nft","title":"Checking burned NFT","text":"<p>To check the burned item:</p> <ul> <li> <p>Use the <code>getItemById</code> API method</p> getItemById <p>Returns Item by ID.</p> <p><code>https://api.rarible.org/v0.1/items/{itemId}</code></p> <p>Example request (staging)</p> <pre><code>curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243'\n</code></pre> <p>Request parameters:</p> <ul> <li> <p><code>itemId</code> \u2014  ItemID of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code></p> <p>For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></p> </li> </ul> <p>Example response (status 200)</p> <pre><code>{\n   \"id\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\",\n   \"blockchain\": \"ETHEREUM\",\n   \"collection\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n   \"contract\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n   \"tokenId\": \"19661880631107248865491477079747186145992059189823053172927066273904580362243\",\n   \"creators\": [\n      {\n         \"account\": \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\",\n         \"value\": 10000\n      }\n   ],\n   \"owners\": [],\n   \"royalties\": [],\n   \"lazySupply\": \"0\",\n   \"pending\": [],\n   \"mintedAt\": \"2022-03-09T22:48:33Z\",\n   \"lastUpdatedAt\": \"2022-03-09T22:50:03.530Z\",\n   \"supply\": \"1\",\n   \"meta\": {\n      \"name\": \"gbgbgbgbgbgb\",\n      \"description\": \"\",\n      \"attributes\": [],\n      \"content\": [\n         {\n            \"@type\": \"IMAGE\",\n            \"url\": \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\",\n            \"representation\": \"ORIGINAL\",\n            \"mimeType\": \"image/jpeg\",\n            \"size\": 13311,\n            \"width\": 640,\n            \"height\": 640\n         }\n      ],\n      \"restrictions\": []\n   },\n   \"deleted\": false,\n   \"auctions\": [],\n   \"totalStock\": \"0\",\n   \"sellers\": 0\n}\n</code></pre> </li> <li> <p>Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos.</p> </li> </ul> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/buy/","title":"Prerequisites","text":"<p>To buy NFT with Rarible Protocol you should have order id for NFT you are interested in - you can get order id with Rarible API</p> <p>You can buy NFTs with Rarible Multichain Protocol on different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/buy/#buy-an-nft","title":"Buy an NFT","text":"<p>You can buy any NFTfor which sell order is created</p> <p>Use <code>buy</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toOrderId} from \"@rarible/types\"\n\nasync function buyNft(orderId: string) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n\n    // Get order info\n    const buy = await sdk.order.buy.prepare({                           \n    orderId: toOrderId(orderId) \n    })\n\n    /**\n     * Number of NFTs to buy or to sell (in case of accepting bids)\n     * amount: number\n     * Origin fees, if not supported by the underlying contract, will throw Error\n     * originFees?: UnionPart[]\n     * Payouts, if not supported by the underlying contract, will throw Error\n     * payouts?: UnionPart[]\n     * Use infinite approvals (for ERC-20)\n     * infiniteApproval?: boolean\n     * ItemId for fill collection order\n     * itemId?: ItemId | ItemId[]\n     * Max fees value. Should be greater than 0. If required and not provided, will throw Error\n     * maxFeesBasePoint?: number,\n     * Force pay royalties. It's working only on AMM orders\n     * addRoyalties?: boolean\n    */\n\n    // Send transaction\n    const result = await buy.submit(\n    amount: 1,    //amount of NFTs you want to buy\n    )\n    // result: IBlockchainTransaction\n}\n</code></pre> <ul> <li><code>orderId</code> \u2014  Id of NFT sale order, has format <code>${blockchain}:${orderId}</code>. For example, <code>ETHEREUM:0x19f487016770542dc6137b06499a4f7b42c9580f12d85d6347964b03b7682143</code></li> <li><code>amount</code> \u2014 amount of NFT tokens you want to buy</li> </ul> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/contract-addresses/","title":"Contract Addresses","text":"<p>Here you can find Rarible Smart Contracts deployed instances across Mainnet, Testnet and Development.</p>"},{"location":"reference/contract-addresses/#mainnet","title":"Mainnet","text":"Contract Addresses Mainnet Ethereum Asset Contract ERC-721 0xc9154424B823b10579895cCBE442d41b9Abd96Ed Asset Contract ERC-1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD NFT Transfer Proxy (for Approvals) 0x4fee7b061c97c9c496b01dbce9cdb10c02f0a0be ERC-721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 ERC-1155 Token Factory 0xDA5BFe0bD4443d63833C8f4E3284357299eaE6BC Exchange Wrapper 0x7f19564C35c681099c0c857a7141836Cf7EDaa53 Locking Contract 0x096Bd9a7a2e703670088C05035e23c7a9F428496 Flow RaribleNFT A.01ab36aaf654a13e.RaribleNFT RaribleOrder A.01ab36aaf654a13e.RaribleOrder RaribleFee A.336405ad2f289b87.RaribleFee LicensedNFT A.01ab36aaf654a13e.LicensedNFT Tezos Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC Polygon Exchange 0x835131b455778559CFdDd358eA3Fc762728F4E3e Transfer Proxies 0xd47e14DD9b98411754f722B4c4074e14752Ada7C ERC-721 Token Factory 0x16911a36a56f828f17632cD4915614Dd5c7a45e0 ERC-1155 Token Factory 0xF46e8e6fA0F048DdD76F8c6982eBD059796298B8"},{"location":"reference/contract-addresses/#testnet","title":"Testnet","text":"Contract Addresses Testnet (Goerli, Mumbai) Ethereum Asset Contract ERC-721 0xD8560C88D1DC85f9ED05b25878E366c49B68bEf9 Asset Contract ERC-1155 0x7c4B13B5893cD82f371c5e28f12FB2F37542BbC5 Exchange Contract 0x02afbD43cAD367fcB71305a2dfB9A3928218f0c1 External Royalties 0xfeC0F8d936B9cBa92a332bCB06dC7DF4DdE0c253 NFT Transfer Proxy (for Approvals) 0x21B0B84FfAB5A8c48291f5eC9D9FDb9aef574052 ERC-721 Token Factory 0x66a1037a48b6A2469cF740aD9Ac42BD47eDF9573 ERC-1155 Token Factory 0xf6dFfCB8E97c7F32f6bb6F0fad60b9D1ED661ba6 Exchange Wrapper 0x013EEa11f00063DB00Af3328C97B8280A8531cF3 Locking Contract 0x39C9D13e1b17Bf1975aFe892e18B1D5A1482b52D Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4"},{"location":"reference/contract-addresses/#development","title":"Development","text":"Contract Addresses Development (Ropsten, Mumbai, Ithaca) Ethereum Asset Contract ERC-721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC-1155 0x6a94aC200342AC823F909F142a65232E2f052183 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 ERC-721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 ERC-1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Tezos royalties KT1AZfqFGFLMUrscNFyawDYAyqXYydz714ya transfer_proxy KT1WbVjXdmBpzzVoYSSUiNt6QFnSC3W768d1 transfer_manager KT1L1WfmvjQRTRqT8Zv4qey4vdZbyML43UT4 fill KT1JtTi6qP5jxks3S12Uq28etuhgJCQ4tXtP exchange KT1S6H2FWxrpaD7aPRSW1cTTE1xPucXBSTL5 nft KT1ANmrMfq6SfPe2b59JGVu2CDacoaoL6hW8 Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4"},{"location":"reference/contract-addresses/#solana","title":"Solana","text":"Contract Addresses All networks SPL_TOKEN_PROGRAM TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA TOKEN_METADATA_PROGRAM metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s RARI_AUCTION_HOUSE_PROGRAM raria47jXd4tdW6Dj7T64mgahwTjMsVaDwFxMHt9Jbp DEGEN_AUCTION_HOUSE_PROGRAM DEGEN3pHdRWgdPsp4PyKT8jmi2arvnpqJpkYiibHfQzA"},{"location":"reference/conversion/","title":"Convert to/from wrapped fungible tokens","text":"<p>To convert to/from wrapped fungible tokens, for example, ETH to WETH, <code>use sdk.balances.convert</code> function:</p> <pre><code>import { Blockchain } from \"@rarible/api-client\"\n\n//Convert 0.1 ETH to 0.1 wETH (Wrapped Ether)\nconst tx = await sdk.balances.convert(Blockchain.ETHEREUM, true, \"0.1\")\nawait tx.wait()\n\n//Or unwrap 0.1 wETH to 0.1 ETH\nconst tx = await sdk.balances.convert(Blockchain.ETHEREUM, false, \"0.1\")\nawait tx.wait()\n</code></pre>"},{"location":"reference/create-collection/","title":"Collection","text":"<p>You can Create NFT Collection with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/create-collection/#create-collection","title":"Create collection","text":"<p>Use <code>createCollection</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { CreateCollectionRequest } from \"@rarible/sdk/src/types/nft/deploy/domain\"\n\nasync function createCollection(wallet: BlockchainWallet, collectionRequest: CreateCollectionRequest) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const result = await sdk.nft.createCollection(collectionRequest)\n    await result.tx.wait()\n    return result.address\n}\n</code></pre> <p>Depending on blockchain type, in <code>collectionRequest</code> should pass the following parameters:</p> <p>Ethereum</p> <pre><code>const ethereumRequest: CreateCollectionRequest = {\n  blockchain: Blockchain.ETHEREUM,\n  asset: {\n    assetType: \"ERC721\",\n    arguments: {\n      name: \"name\",\n      symbol: \"RARI\",\n      baseURI: \"https://ipfs.rarible.com\",\n      contractURI: \"https://ipfs.rarible.com\",\n      isUserToken: false,\n    },\n  },\n}\n</code></pre> <p>Tezos</p> <pre><code>const tezosRequest: CreateCollectionRequest = {\n  blockchain: Blockchain.TEZOS,\n  asset: {\n    assetType: \"NFT\",\n    arguments: {\n      name: \"My NFT collection\",\n      symbol: \"MYNFT\",\n      contractURI: \"https://ipfs.io/ipfs/QmTKxwnqqxTxH4HE3UVM9yoJFZgbsZ8CuqqRFZCSWBF53m\",\n      isUserToken: false,\n    },\n  },\n}\n</code></pre> <ul> <li><code>blockchain</code> \u2014 blockchain type: <code>ETHEREUM</code> or <code>TEZOS</code></li> <li><code>assetType</code> \u2014 NFT collection type: <code>ERC721</code> or <code>ERC1155</code> for <code>ETHEREUM</code>, <code>NFT</code> or <code>MT</code> for <code>TEZOS</code></li> <li><code>name</code> \u2014 name of the collection</li> <li><code>symbol</code> \u2014 symbol of the collection</li> <li><code>baseURI</code> \u2014 prefix of the result of the tokenURI call</li> <li><code>contractURI</code> \u2014 URI meta of the entire collection</li> <li><code>isUserToken</code> \u2014 privat (true) or public (false) collection</li> </ul>"},{"location":"reference/create-collection/#checking-created-collection","title":"Checking created collection","text":"<p>To check the created collection:</p> <ul> <li> <p>Use the <code>getCollectionById</code> API method</p> getCollectionById <p>Returns collection by address.</p> <p><code>https://api.rarible.org/v0.1/collections/{collection}</code></p> <p>Example request (staging)</p> <pre><code>curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&amp;size=3'\n</code></pre> <p>Example response (status 200)</p> <pre><code>{\n    \"total\": 3,\n    \"continuation\": \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\",\n    \"collections\": [\n        {\n            \"id\": \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\",\n            \"blockchain\": \"ETHEREUM\",\n            \"type\": \"ERC721\",\n            \"name\": \"CryptoKitties\",\n            \"symbol\": \"CK\",\n            \"features\": [],\n            \"minters\": []\n        },\n        {\n            \"id\": \"ETHEREUM:0xaf2584a8b198f5d0b360b95d92aec852f7902e52\",\n            \"blockchain\": \"ETHEREUM\",\n            \"type\": \"CRYPTO_PUNKS\",\n            \"name\": \"CRYPTOPUNKS\",\n            \"symbol\": \"(\u03fe)\",\n            \"owner\": \"ETHEREUM:0xfb571f9da71d1ac33e069571bf5c67fadcff18e4\",\n            \"features\": [],\n            \"minters\": []\n        },\n        {\n            \"id\": \"ETHEREUM:0xd0200fa0a9c94484c7152813313b122e31bed99d\",\n            \"blockchain\": \"ETHEREUM\",\n            \"type\": \"ERC721\",\n            \"name\": \"CryptoKitties\",\n            \"symbol\": \"CK\",\n            \"features\": [],\n            \"minters\": []\n        }\n    ]\n}\n</code></pre> </li> <li> <p>Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos.</p> </li> </ul> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/get-balance/","title":"Get balance","text":"<p>You can transfer NFTs with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p> <p>To get balance of your wallet, use <code>getBalance</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { AssetType } from \"@rarible/api-client\"\n\nasync function getBalance(wallet: BlockchainWallet, assetType: AssetType) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const balance = await sdk.balances.getBalance(\n        toUnionAddress(\"&lt;YOUR_WALLET_ADDRESS&gt;\"),\n        assetType\n    )\n    return balance\n}\n</code></pre> <p>For getting balance from Polygon:</p> <ul> <li> <p>Matic</p> <pre><code>const balance = await sdk.balances.getBalance(\n  toUnionAddress(\"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\"), {\n \"@type\": \"ETH\",\n blockchain: Blockchain.POLYGON,\n})\n</code></pre> </li> <li> <p>ERC20</p> <pre><code>const balance = await sdk.balances.getBalance(\ntoUnionAddress(\"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\"), {\n            \"@type\": \"ERC20\",\n            contract: toCollectionId(\"POLYGON:0xa6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa\"),\n})\n</code></pre> </li> </ul>"},{"location":"reference/install-sdk/","title":"Install Rarible SDK","text":"<pre><code>yarn add @rarible/sdk -D\nyarn add web3@1.5.0\nyarn add tslib@2.3.1\n</code></pre> <p>If you need to initialize the wallets with ethers, you can install it like this:</p> <pre><code>yarn add ethers\n</code></pre> <p>To make sure the SDK is installed correctly, check version:</p> <pre><code>npm view @rarible/sdk version\n</code></pre>"},{"location":"reference/install-sdk/#initialize-wallets","title":"Initialize wallets","text":"<p>To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets.</p> <p>Read more about initializing wallets on Wallets page.</p>"},{"location":"reference/install-sdk/#using-sdk-on-client-application","title":"Using SDK on client application","text":"<p>SDK is written in TypeScript. You can use typings to explore SDK possibilities.</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\n</code></pre>"},{"location":"reference/install-sdk/#using-sdk-on-server-application","title":"Using SDK on server application","text":"<p>The SDK was designed for use on the frontend side. To use the SDK on the server side (backend):</p> <ol> <li> <p>Install packages:</p> <pre><code>yarn add tslib@2.3.1\nyarn add form-data\nyarn add node-fetch\n</code></pre> </li> <li> <p>Add dependencies:</p> <pre><code>global.FormData = require(\"form-data\")\nglobal.window = {\n  fetch: require(\"node-fetch\"),\n  dispatchEvent: () =&gt; {\n  },\n}\nglobal.CustomEvent = function CustomEvent() {\n  return\n}\n</code></pre> </li> <li> <p>Try our example to buy Ethereum NFT item on Rinkeby network.</p> <p>Pass private key, node RPC URL, network ID, item ID for buyout and start:</p> <pre><code>ETH_PRIVATE_KEY=\"0x...\" \\\nETHEREUM_RPC_URL=\"https://rinkeby.infura.io/...\" \\\nETHEREUM_NETWORK_ID=\"4\" \\\nBUYOUT_ITEM_ID=\"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\\nts-node packages/sdk/example/backend/buy.ts\n</code></pre> </li> </ol>"},{"location":"reference/mint-and-sell/","title":"Mint and Sell","text":"<p>You can prepare Mint and put up on Sale NFTs with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/mint-and-sell/#mint-and-list-nft-for-sale","title":"Mint and List NFT for sale","text":"<p>Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the <code>mintOnChain</code> function with <code>sellAction</code>:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toCollectionId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\"\nimport type { RequestCurrency } from \"@rarible/sdk/build/common/domain\"\n\nasync function mintAndSell(wallet: BlockchainWallet, currency: RequestCurrency) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n\n    const mintAction = await sdk.nft.mintAndSell({\n        collectionId: toCollectionId(\"&lt;NFT_CONTRACT_ADDRESS&gt;\"),\n    })\n    /*\n    You should upload json file with item metadata in the following format:\n    {\n      name: string\n      description: string | undefined\n      image: string | undefined\n      \"animation_url\": string | undefined\n      \"external_url\": string | undefined\n      attributes: TokenMetadataAttribute[]\n    }\n    and insert link to json file to \"uri\" field.\n    To format your json data use \"sdk.nft.preprocessMeta()\" method\n   */\n    const mintResult = await mintAction.submit({\n        uri: \"&lt;YOUR_LINK_TO_JSON&gt;\",\n        royalties: [{\n            account: toUnionAddress(\"&lt;ROYLATY_ADDRESS&gt;\"),\n            value: 1000,\n        }],\n        creators: [{\n            account: toUnionAddress(\"&lt;CREATOR_ADDRESS&gt;\"),\n            value: 10000,\n        }],\n        lazyMint: true,\n        supply: 1,\n        price: \"0.000000000000000001\",\n        currency,\n    })\n    if (mintResult.type === MintType.OFF_CHAIN) {\n        return mintResult.itemId\n    }\n}\n</code></pre> <ul> <li><code>collectionId</code> \u2014 your collection address, that can be already deployed. Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page</li> <li><code>ContractAddress</code> \u2014 <code>BlockchainName:HexAddress</code> = <code>ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05</code><ul> <li><code>BlockchainName</code> \u2014 <code>ETHEREUM</code>, <code>FLOW</code>, <code>TEZOS</code> or <code>POLYGON</code></li> </ul> </li> <li><code>uri</code> \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp</li> <li><code>royalties</code> \u2014 value and address for receiving royalties<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the royalties. For example, 2,5% value is <code>250</code></li> </ul> </li> <li><code>creators</code> \u2014 value and address of the creator<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the royalties. For example, 2,5% value is <code>250</code></li> </ul> </li> <li><code>lazyMint</code> \u2014 boolean, <code>false</code> if you want to mint item on the blockchain, <code>true</code> allow to you mint off-chain item without spending the gas</li> <li><code>supply</code> \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading <code>sdk.nft.mint</code> response under multiple parameters)</li> <li><code>price</code> \u2014 price per 1 NFT in ETH</li> <li><code>currency</code> \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.)</li> </ul>"},{"location":"reference/mint-and-sell/#update-listed-token-price","title":"Update listed token price","text":"<p>Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one.</p> <p>For update listed NFT price use the <code>sellAndUpdate</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { RequestCurrency } from \"@rarible/sdk/build/common/domain\"\n\nasync function sellAndUpdate(wallet: BlockchainWallet, assetType: RequestCurrency) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const sellAction = await sdk.order.sell({\n        itemId: toItemId(\"&lt;YOUR_ITEM_ID&gt;\"),\n    })\n    const sellOrderId = await sellAction.submit({\n        amount: 1,\n        price: \"0.000002\",\n        currency: assetType,\n    })\n    const updateAction = await sdk.order.sellUpdate({ orderId: sellOrderId })\n    //You can only decrease price of sell order for security reasons\n    //If you want to force change sell price you should cancel sell order\n    await updateAction.submit({ price: \"0.000001\" })\n}\n</code></pre>"},{"location":"reference/mint-and-sell/#checking-created-order","title":"Checking created order","text":"<p>To check the created order use the <code>getOrderById</code> API method</p> getOrderById <p>Returns Order by ID.</p> <p><code>https://api.rarible.org/v0.1/orders/{id}</code></p> <p>Example request (staging)</p> <pre><code>curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed'\n</code></pre> <p>Request parameters:</p> <ul> <li> <p><code>id</code> \u2014  ID of your order, has format <code>${blockchain}:${id}</code></p> <p>For example, <code>ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed</code></p> </li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"id\": \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\",\n  \"fill\": \"0.00001\",\n  \"platform\": \"RARIBLE\",\n  \"status\": \"FILLED\",\n  \"makeStock\": \"0\",\n  \"cancelled\": false,\n  \"createdAt\": \"2022-03-11T12:09:14.904Z\",\n  \"lastUpdatedAt\": \"2022-03-11T12:17:21Z\",\n  \"makePrice\": \"0.00001\",\n  \"makePriceUsd\": \"0.026062773565248403\",\n  \"priceHistory\": [\n    {\n      \"date\": \"2022-03-11T12:09:14.904Z\",\n      \"makeValue\": \"1\",\n      \"takeValue\": \"0.00001\"\n    }\n  ],\n  \"maker\": \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\",\n  \"make\": {\n    \"type\": {\n      \"@type\": \"ERC1155_Lazy\",\n      \"contract\": \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\",\n      \"tokenId\": \"19906957776073516298368660511705840565672843874722253325423575352615771308035\",\n      \"uri\": \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\",\n      \"supply\": \"1\",\n      \"creators\": [\n        {\n          \"account\": \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\",\n          \"value\": 10000\n        }\n      ],\n      \"royalties\": [\n        {\n          \"account\": \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\",\n          \"value\": 1000\n        }\n      ],\n      \"signatures\": [\n          \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\"\n      ]\n    },\n    \"value\": \"1\"\n  },\n  \"take\": {\n    \"type\": {\n      \"@type\": \"ETH\",\n      \"blockchain\": \"ETHEREUM\"\n    },\n    \"value\": \"0.00001\"\n  },\n  \"salt\": \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\",\n  \"signature\": \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\",\n  \"pending\": [],\n  \"data\": {\n    \"@type\": \"ETH_RARIBLE_V2\",\n    \"payouts\": [],\n    \"originFees\": []\n  }\n}\n</code></pre> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/mint/","title":"Mint","text":"<p>You can Mint NFTs with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/mint/#minting-multichain","title":"Minting Multichain","text":""},{"location":"reference/mint/#lazy-minting-off-chain","title":"Lazy Minting (off-chain)","text":"<p>Use <code>mintOffChain</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toCollectionId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\"\n\nasync function mintOffChain(wallet: BlockchainWallet, contractAddress: string) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n\n    const mintAction = await sdk.nft.mint({\n        collectionId: toCollectionId(contractAddress),\n    })\n    /*\n    You should upload json file with item metadata in the following format:\n    {\n      name: string\n      description: string | undefined\n      image: string | undefined\n      \"animation_url\": string | undefined\n      \"external_url\": string | undefined\n      attributes: TokenMetadataAttribute[]\n    }\n    and insert link to json file to \"uri\" field.\n    To format your json data use \"sdk.nft.preprocessMeta()\" method\n   */\n    const mintResult = await mintAction.submit({\n        uri: \"&lt;YOUR_LINK_TO_JSON&gt;\",\n        royalties: [{\n            account: toUnionAddress(\"&lt;ROYLATY_ADDRESS&gt;\"),\n            value: 1000,\n        }],\n        creators: [{\n            account: toUnionAddress(\"&lt;CREATOR_ADDRESS&gt;\"),\n            value: 10000,\n        }],\n        lazyMint: true,\n        supply: 1,\n    })\n    if (mintResult.type === MintType.OFF_CHAIN) {\n        return mintResult.itemId\n    }\n}\n</code></pre> <ul> <li><code>collectionId</code> \u2014 your collection address, that can be already deployed. Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page</li> <li><code>ContractAddress</code> \u2014 <code>BlockchainName:HexAddress</code> = <code>ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05</code><ul> <li><code>BlockchainName</code> \u2014 <code>ETHEREUM</code>, <code>FLOW</code>, <code>TEZOS</code> or <code>POLYGON</code></li> </ul> </li> <li><code>uri</code> \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp</li> <li><code>royalties</code> \u2014 value and address for receiving royalties<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the royalties. For example, 10% value is <code>1000</code></li> </ul> </li> <li><code>creators</code> \u2014 value and address of the creator<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the part in the ownership of the item. For example, 100% value is <code>10000</code>. If there are several owners, the total cost cannot be more than <code>10000</code></li> </ul> </li> <li><code>lazyMint</code> \u2014 boolean, <code>false</code> if you want to mint item on the blockchain, <code>true</code> allow to you mint off-chain item without spending the gas</li> <li><code>supply</code> \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading <code>sdk.nft.mint</code> response under multiple parameters)</li> </ul> <p>Example of a successful response:</p> <pre><code>itemId: \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\";\ntype: \"off-chain\"\n</code></pre> <ul> <li><code>itemId</code> \u2014  Id of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code>. For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></li> </ul>"},{"location":"reference/mint/#minting-on-chain","title":"Minting (on-chain)","text":"<p>Use <code>mintOnChain</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toCollectionId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\"\n\nasync function mintOnChain(wallet: BlockchainWallet, contractAddress: string) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n\n    const mintAction = await sdk.nft.mint({\n        collectionId: toCollectionId(contractAddress),\n    })\n    /*\n  You should upload json file with item metadata in the following format:\n  {\n    name: string\n    description: string | undefined\n    image: string | undefined\n    \"animation_url\": string | undefined\n    \"external_url\": string | undefined\n    attributes: TokenMetadataAttribute[]\n    }\n    and insert link to json file to \"uri\" field.\n    To format your json data use \"sdk.nft.preprocessMeta()\" method\n   */\n    const mintResult = await mintAction.submit({\n        uri: \"&lt;YOUR_LINK_TO_JSON&gt;\",\n        //optional\n        royalties: [{\n            account: toUnionAddress(\"&lt;ROYLATY_ADDRESS&gt;\"),\n            value: 1000,\n        }],\n        //optional\n        creators: [{\n            account: toUnionAddress(\"&lt;CREATOR_ADDRESS&gt;\"),\n            value: 10000,\n        }],\n        lazyMint: false,\n        supply: 1,\n    })\n    if (mintResult.type === MintType.ON_CHAIN) {\n        await mintResult.transaction.wait()\n        return mintResult.itemId\n    }\n}\n</code></pre>"},{"location":"reference/mint/#minting-with-tokenid","title":"Minting with tokenId","text":"<p>Usually the <code>tokenId</code> is generated automatically. If you need to get a <code>tokenId</code> before, for example, you want to upload data to the IPFS, use <code>mintOnChainWithTokenId</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toCollectionId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\"\n\nasync function mintOnChainWithTokenId(wallet: BlockchainWallet, contractAddress: string) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n\n    const collectionId = toCollectionId(contractAddress)\n    //Get tokenId for collection and mint\n    const tokenId = await sdk.nft.generateTokenId({\n        collection: collectionId,\n        minter: toUnionAddress(\"&lt;CREATOR_ADDRESS&gt;\"),\n    })\n\n    const mintAction = await sdk.nft.mint({\n        collectionId,\n        tokenId,\n    })\n    /*\n  You should upload json file with item metadata with the following format:\n  {\n    name: string\n    description: string | undefined\n    image: string | undefined\n    \"animation_url\": string | undefined\n    \"external_url\": string | undefined\n    attributes: TokenMetadataAttribute[]\n  }\n  and insert link to json file to \"uri\" field.\n  To format your json data use \"sdk.nft.preprocessMeta()\" method\n   */\n    const mintResult = await mintAction.submit({\n        uri: \"&lt;YOUR_LINK_TO_JSON&gt;\",\n        //optional\n        royalties: [{\n            account: toUnionAddress(\"&lt;ROYLATY_ADDRESS&gt;\"),\n            value: 1000,\n        }],\n        //optional, by default creator=minter\n        creators: [{\n            account: toUnionAddress(\"&lt;CREATOR_ADDRESS&gt;\"),\n            value: 10000,\n        }],\n        lazyMint: false,\n        supply: 1,\n    })\n    if (mintResult.type === MintType.ON_CHAIN) {\n        await mintResult.transaction.wait()\n        return mintResult.itemId\n    }\n}\n</code></pre>"},{"location":"reference/mint/#checking-created-nft","title":"Checking created NFT","text":"<p>To check the created item:</p> <ul> <li> <p>Use the <code>getItemById</code> API method</p> getItemById <p>Returns Item by ID.</p> <p><code>https://api.rarible.org/v0.1/items/{itemId}</code></p> <p>Example request (staging)</p> <pre><code>curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243'\n</code></pre> <p>Request parameters:</p> <ul> <li> <p><code>itemId</code> \u2014  ItemID of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code></p> <p>For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></p> </li> </ul> <p>Example response (status 200)</p> <pre><code>{\n   \"id\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\",\n   \"blockchain\": \"ETHEREUM\",\n   \"collection\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n   \"contract\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n   \"tokenId\": \"19661880631107248865491477079747186145992059189823053172927066273904580362243\",\n   \"creators\": [\n      {\n         \"account\": \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\",\n         \"value\": 10000\n      }\n   ],\n   \"owners\": [],\n   \"royalties\": [],\n   \"lazySupply\": \"0\",\n   \"pending\": [],\n   \"mintedAt\": \"2022-03-09T22:48:33Z\",\n   \"lastUpdatedAt\": \"2022-03-09T22:50:03.530Z\",\n   \"supply\": \"1\",\n   \"meta\": {\n      \"name\": \"gbgbgbgbgbgb\",\n      \"description\": \"\",\n      \"attributes\": [],\n      \"content\": [\n         {\n            \"@type\": \"IMAGE\",\n            \"url\": \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\",\n            \"representation\": \"ORIGINAL\",\n            \"mimeType\": \"image/jpeg\",\n            \"size\": 13311,\n            \"width\": 640,\n            \"height\": 640\n         }\n      ],\n      \"restrictions\": []\n   },\n   \"deleted\": false,\n   \"auctions\": [],\n   \"totalStock\": \"0\",\n   \"sellers\": 0\n}\n</code></pre> </li> <li> <p>Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos.</p> </li> </ul> <p>You can find more information about Mint in Rarible Protocol SDK. Or you can use it as a regular async function and work with regular Promises.</p>"},{"location":"reference/mint/#minting-in-specific-blockchain-networks","title":"Minting in specific blockchain networks","text":"<p>We recommend using the Multichain Protocol for minting tokens. But you can also make Mint on a specific blockchain network.</p> Ethereum <p>With Rarible Protocol Ethereum SDK, you can mint and lazy mint ERC-721 and ERC-1155 NFT tokens in the Ethereum network.</p> <p>Mint</p> <p>Minting is using the <code>mintAndTransfer</code> function for ERC-721 and ERC-1155 contracts.</p> <p>For ERC-721, the function has the following signature:<code>mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to)</code>.</p> <pre><code>struct Mint721Data {\n        uint tokenId;\n        string tokenURI;\n        address[] creators;\n        LibPart.Part[] royalties;\n        bytes[] signatures;\n}\n</code></pre> <ul> <li>tokenId \u2014 tokenId of the ERC-721 standard</li> <li>tokenURI \u2014 suffix for the token URI. The prefix is usually <code>ipfs://ipfs/</code></li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.</li> </ul> <p>For ERC-1155, the function has the following signature: <code>mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount)</code>.</p> <pre><code>struct Mint1155Data {\n        uint tokenId;\n        string tokenURI;\n        uint supply;\n        address[] creators;\n        LibPart.Part[] royalties;\n        bytes[] signatures;\n}\n</code></pre> <ul> <li>tokenId \u2014 tokenId of the ERC-1155 standard</li> <li>tokenURI \u2014 suffix for the token URI. The prefix is usually <code>ipfs://ipfs/</code></li> <li>supply \u2014 total number of tokens for minting</li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.</li> </ul> <p>Lazy Mint</p> <p>Lazy Minting is supported for ERC-721 and ERC-1155.</p> <p> Lazy mint </p> <p>To create Lazy Minting:</p> <ol> <li>Generate a token ID</li> <li>Create a Lazy Minting request body that the creator must sign</li> <li>The creator signs the provided data</li> <li>Add signature to the request body</li> <li>Send the data to the API</li> </ol> <p>For more information about Lazy Minting, see SDK page. </p> Flow <p>With Rarible Protocol Flow SDK, you can mint Flow NFT tokens.</p> <p>Mint response represents transaction result extended with <code>txId</code> and minted <code>tokenId</code></p> <pre><code>const {\n  txId, // transaction id\n  tokenId, // minted tokenId\n  status, // flow transaction status\n  statusCode, // flow transaction statusCode - for example: value 4 for sealed transaction\n  errorMessage,\n  events, // events generated from contract and include all events produced by transaction, deopsits withdrown etc.\n} = await sdk.nft.mint(collection, \"your meta info\", [])\n</code></pre> Tezos <p>With Rarible Protocol Tezos SDK, you can mint Tezos NFT tokens.</p> <pre><code>const result = await mint(\n  provider: Provider,\n  contract: string,\n  royalties : { [key: string]: BigNumber },\n  supply?: BigNumber,\n  token_id?: BigNumber,\n  metadata?: { [key: string]: string },\n  owner?: string,\n)\n</code></pre> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/order/","title":"Sell Order","text":"<p>When you have your NFT created, there is a high chance that you will want to sell it. Or try, at least. You can Sell NFTs with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/order/#list-nft-for-sale","title":"List NFT for sale","text":"<p>Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the <code>mintOnChain</code> function with <code>sellAction</code>:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { RequestCurrency } from \"@rarible/sdk/build/common/domain\"\n\nasync function mintOnChain(wallet: BlockchainWallet, assetType: RequestCurrency) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const sellResponse = await sdk.order.sell({\n        itemId: toItemId(\"&lt;YOUR_ITEM_ID&gt;\"),\n    })\n    const sellOrderId = await sellResponse.submit({\n        amount: 1,\n        price: \"0.000002\",\n        currency: assetType,\n        originFees: [{\n            account: toUnionAddress(\"&lt;COMISSION_ADDRESS&gt;\"),\n            //2,5%\n            value: 250,\n        }],\n        payouts: [{\n            account: toUnionAddress(\"&lt;PAYOUT_ADDRESS&gt;\"),\n            //5%\n            value: 500,\n        }],\n        //+1 hour\n        expirationDate: new Date(Date.now() + 60 * 60 * 1000),\n    })\n    return sellOrderId\n}\n</code></pre> <ul> <li><code>itemId</code> \u2014  ItemID of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code>. For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></li> <li><code>amount</code> \u2014 amount of NFT tokens for sale</li> <li><code>price</code> \u2014 price per 1 NFT in ETH</li> <li><code>currency</code> \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.)</li> <li><code>originFees</code> \u2014 value and address of the origin fees for the order<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the fees. For example, 2,5% value is <code>250</code></li> </ul> </li> <li><code>payouts</code> \u2014 value and address of the payouts for the order<ul> <li><code>account</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>value</code> \u2014 value of the payouts. For example, 5% value is <code>500</code></li> </ul> </li> </ul>"},{"location":"reference/order/#update-listed-token-price","title":"Update listed token price","text":"<p>Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one.</p> <p>For update listed NFT price use the <code>sellAndUpdate</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\nimport type { RequestCurrency } from \"@rarible/sdk/build/common/domain\"\n\nasync function sellAndUpdate(wallet: BlockchainWallet, assetType: RequestCurrency) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const sellAction = await sdk.order.sell({\n        itemId: toItemId(\"&lt;YOUR_ITEM_ID&gt;\"),\n    })\n    const sellOrderId = await sellAction.submit({\n        amount: 1,\n        price: \"0.000002\",\n        currency: assetType,\n        originFees: [{\n            account: toUnionAddress(\"&lt;COMISSION_ADDRESS&gt;\"),\n            //2,5%\n            value: 250,\n        }],\n        payouts: [{\n            account: toUnionAddress(\"&lt;PAYOUT_ADDRESS&gt;\"),\n            //5%\n            value: 500,\n        }],\n    })\n    const updateAction = await sdk.order.sellUpdate({ orderId: sellOrderId })\n    //You can only decrease price of sell order for security reasons\n    //If you want to force change sell price you should cancel sell order\n    await updateAction.submit({ price: \"0.000001\" })\n}\n</code></pre>"},{"location":"reference/order/#checking-created-order","title":"Checking created order","text":"<p>To check the created order use the <code>getOrderById</code> API method</p> getOrderById <p>Returns Order by ID.</p> <p><code>https://api.rarible.org/v0.1/orders/{id}</code></p> <p>Example request (staging)</p> <pre><code>curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed'\n</code></pre> <p>Request parameters:</p> <ul> <li> <p><code>id</code> \u2014  ID of your order, has format <code>${blockchain}:${id}</code></p> <p>For example, <code>ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed</code></p> </li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"id\": \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\",\n  \"fill\": \"0.00001\",\n  \"platform\": \"RARIBLE\",\n  \"status\": \"FILLED\",\n  \"makeStock\": \"0\",\n  \"cancelled\": false,\n  \"createdAt\": \"2022-03-11T12:09:14.904Z\",\n  \"lastUpdatedAt\": \"2022-03-11T12:17:21Z\",\n  \"makePrice\": \"0.00001\",\n  \"makePriceUsd\": \"0.026062773565248403\",\n  \"priceHistory\": [\n    {\n      \"date\": \"2022-03-11T12:09:14.904Z\",\n      \"makeValue\": \"1\",\n      \"takeValue\": \"0.00001\"\n    }\n  ],\n  \"maker\": \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\",\n  \"make\": {\n    \"type\": {\n      \"@type\": \"ERC1155_Lazy\",\n      \"contract\": \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\",\n      \"tokenId\": \"19906957776073516298368660511705840565672843874722253325423575352615771308035\",\n      \"uri\": \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\",\n      \"supply\": \"1\",\n      \"creators\": [\n        {\n          \"account\": \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\",\n          \"value\": 10000\n        }\n      ],\n      \"royalties\": [\n        {\n          \"account\": \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\",\n          \"value\": 1000\n        }\n      ],\n      \"signatures\": [\n          \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\"\n      ]\n    },\n    \"value\": \"1\"\n  },\n  \"take\": {\n    \"type\": {\n      \"@type\": \"ETH\",\n      \"blockchain\": \"ETHEREUM\"\n    },\n    \"value\": \"0.00001\"\n  },\n  \"salt\": \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\",\n  \"signature\": \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\",\n  \"pending\": [],\n  \"data\": {\n    \"@type\": \"ETH_RARIBLE_V2\",\n    \"payouts\": [],\n    \"originFees\": []\n  }\n}\n</code></pre> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/reference-overview/","title":"Overview","text":"<p>Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets and list them to sell, trade, etc.</p> <p>In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box.</p> <p>See more information about API on API Reference page. </p> <p>First Steps</p> <ol> <li>Install SDK</li> <li>Initialize Wallets</li> <li> <p>See how to use common functionality:</p> <ul> <li>Create collection</li> <li>Mint NFT</li> <li>Sell NFTs</li> <li>Mint and Sell</li> <li>Create and Accept Bid</li> <li>Transfer tokens</li> <li>Burn tokens</li> <li>Get wallet balance</li> <li>Tokens conversion</li> </ul> </li> <li> <p>Check Contract Addresses and Search Capabilities</p> </li> </ol>"},{"location":"reference/search-capabilities/","title":"Search Capabilities","text":"<p>On the multichain-api.rarible.org you can find main information about Protocol API.</p> <p>ATTENTION: Flow blockchain is temporary out of support - no data is provided on API for Flow blockchain, direct API calls with FLOW blockchain specified are ruturning ERROR 400 \"Flow is not supported\"</p>"},{"location":"reference/search-capabilities/#controllers","title":"Controllers","text":"<p>Use the following controllers to search information about NFT with our multichain API:</p> <ul> <li>Signature controller \u2014 uses for validation of the order signature</li> <li>Currency controller \u2014 getting currency USD rate</li> <li>Item controller \u2014 getting information about NFT items</li> <li>Ownership controller \u2014 getting information about NFT items ownership</li> <li>Order controller \u2014 getting information about NFT orders</li> <li>Auction controller \u2014 getting information about NFT auctions</li> <li>Activity controller \u2014 getting information about activities with NFT</li> <li>Collection controller \u2014 getting information about NFT collections</li> </ul>"},{"location":"reference/search-capabilities/#api-usage-examples","title":"API usage Examples","text":""},{"location":"reference/search-capabilities/#items","title":"Items","text":"get Item by owner <p>Returns Item by owner</p> <p><code>https://api.rarible.org/v0.1/items/byOwner</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/items/byOwner?owner=ETHEREUM:0x2e2d91093341493d4722083e710110163c3be5b9&amp;size=1'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>owner</code> \u2014 address of the item owner, has format <code>${blockchain}:${address}</code>. For example, <code>ETHEREUM:0x2e2d91093341493d4722083e710110163c3be5b9</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"continuation\": \"1645421913958_POLYGON:0x828383b51514873cc937ee83f57fbbff0221700c:13471465447374847834598764369914954310108963722019096037095232973924004254539:0x2e2d91093341493d4722083e710110163c3be5b9\",\n  \"items\": [\n    {\n      \"id\": \"POLYGON:0x828383b51514873cc937ee83f57fbbff0221700c:13471465447374847834598764369914954310108963722019096037095232973924004254539\",\n      \"blockchain\": \"POLYGON\",\n      \"collection\": \"POLYGON:0x828383b51514873cc937ee83f57fbbff0221700c\",\n      \"contract\": \"POLYGON:0x828383b51514873cc937ee83f57fbbff0221700c\",\n      \"tokenId\": \"13471465447374847834598764369914954310108963722019096037095232973924004254539\",\n      \"creators\": [\n        {\n          \"account\": \"ETHEREUM:0x2e2d91093341493d4722083e710110163c3be5b9\",\n          \"value\": 10000\n        }\n      ],\n      \"lazySupply\": \"0\",\n      \"pending\": [],\n      \"mintedAt\": \"2022-02-21T05:38:22Z\",\n      \"lastUpdatedAt\": \"2022-02-21T05:38:33.958Z\",\n      \"supply\": \"1\",\n      \"meta\": {\n        \"name\": \"Unnamed territory\",\n        \"description\": \"**NextEarth LAND NFT**\\n\\n\u0130T\u00dc G\u00fcm\u00fc\u015fsuyu \u00d6\u011frenci Yurdu, \u0130T\u00dc G\u00fcm\u00fc\u015fsuyu Yerle\u015fkesi, Beyoglu, Istanbul 34437, Turkey\",\n        \"tags\": [],\n        \"genres\": [],\n        \"attributes\": [\n          {\n            \"key\": \"Type\",\n            \"value\": \"Land\"\n          },\n          {\n            \"key\": \"Has water\",\n            \"value\": \"No\"\n          },\n          {\n            \"key\": \"Has non-urban\",\n            \"value\": \"No\"\n          },\n          {\n            \"key\": \"Has urban\",\n            \"value\": \"Yes\"\n          },\n          {\n            \"key\": \"Pack Purchase\",\n            \"value\": \"No\"\n          },\n          {\n            \"key\": \"Tile count\",\n            \"value\": \"1\"\n          },\n          {\n            \"key\": \"Urban\",\n            \"value\": \"1\"\n          },\n          {\n            \"key\": \"Non Urban\",\n            \"value\": \"0\"\n          },\n          {\n            \"key\": \"Water\",\n            \"value\": \"0\"\n          },\n          {\n            \"key\": \"Country\",\n            \"value\": \"Turkey\"\n          }\n        ],\n        \"content\": [\n          {\n            \"@type\": \"IMAGE\",\n            \"url\": \"https://storage.googleapis.com/cdn-pub-production-nextearth-io/data/ae5db33b-e770-4e5d-81cf-e074a08d57eb/nft-image/57d55696-24dd-49f4-8f31-15102acc9554.png\",\n            \"representation\": \"ORIGINAL\",\n            \"mimeType\": \"image/png\",\n            \"size\": 812417,\n            \"width\": 1024,\n            \"height\": 1024\n          }\n        ],\n        \"restrictions\": []\n      },\n      \"deleted\": false,\n      \"originOrders\": [],\n      \"ammOrders\": {\n        \"ids\": []\n      },\n      \"auctions\": [],\n      \"totalStock\": \"0\",\n      \"sellers\": 0\n    }\n  ]\n}\n</code></pre> get Item by Id <p>Returns Item by Id</p> <p><code>https://api.rarible.org/v0.1/items/{itemId}</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/items/ETHEREUM:0xb66a603f4cfe17e3d27b87a8bfcad319856518b8:20886900154002869811386593404403268730099008514936490854803004457464658657286'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>itemId</code> \u2014 Id of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code>. For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"id\": \"ETHEREUM:0xb66a603f4cfe17e3d27b87a8bfcad319856518b8:20886900154002869811386593404403268730099008514936490854803004457464658657286\",\n  \"blockchain\": \"ETHEREUM\",\n  \"collection\": \"ETHEREUM:0xb66a603f4cfe17e3d27b87a8bfcad319856518b8\",\n  \"contract\": \"ETHEREUM:0xb66a603f4cfe17e3d27b87a8bfcad319856518b8\",\n  \"tokenId\": \"20886900154002869811386593404403268730099008514936490854803004457464658657286\",\n  \"creators\": [\n    {\n      \"account\": \"ETHEREUM:0x2e2d91093341493d4722083e710110163c3be5b9\",\n      \"value\": 10000\n    }\n  ],\n  \"lazySupply\": \"100\",\n  \"pending\": [],\n  \"mintedAt\": \"2022-01-04T09:30:45.322Z\",\n  \"lastUpdatedAt\": \"2022-01-04T09:30:45.322Z\",\n  \"supply\": \"100\",\n  \"meta\": {\n    \"name\": \"night owl\",\n    \"description\": \"night owls only survive at night\",\n    \"tags\": [],\n    \"genres\": [],\n    \"attributes\": [],\n    \"content\": [\n      {\n        \"@type\": \"IMAGE\",\n        \"url\": \"https://ipfs.infura.io/ipfs/QmYUxZSD8yUZk6zLxSZPvRXu1eQduUgS4b3P9UNd4yoHGk/image.jpeg\",\n        \"representation\": \"ORIGINAL\",\n        \"mimeType\": \"image/jpeg\",\n        \"size\": 1554451,\n        \"width\": 3120,\n        \"height\": 4160\n      }\n    ],\n    \"restrictions\": []\n  },\n  \"deleted\": false,\n  \"bestSellOrder\": {\n    \"id\": \"ETHEREUM:0xabf742f5c6959ec1f4cf353c477fd51af8ecb7e080989a4959755197132be68b\",\n    \"fill\": \"0\",\n    \"platform\": \"RARIBLE\",\n    \"status\": \"ACTIVE\",\n    \"makeStock\": \"100\",\n    \"cancelled\": false,\n    \"optionalRoyalties\": false,\n    \"createdAt\": \"2022-01-04T09:31:37.405Z\",\n    \"lastUpdatedAt\": \"2022-01-04T09:31:37.405Z\",\n    \"dbUpdatedAt\": \"2022-01-04T09:31:37.405Z\",\n    \"makePrice\": \"0.091\",\n    \"makePriceUsd\": \"103.4470817788344755\",\n    \"maker\": \"ETHEREUM:0x2e2d91093341493d4722083e710110163c3be5b9\",\n    \"make\": {\n      \"type\": {\n        \"@type\": \"ERC1155_Lazy\",\n        \"contract\": \"ETHEREUM:0xb66a603f4cfe17e3d27b87a8bfcad319856518b8\",\n        \"tokenId\": \"20886900154002869811386593404403268730099008514936490854803004457464658657286\",\n        \"uri\": \"/ipfs/QmSy7ca3AWHYiNL8rKaU3JueAXgiD8UEupfGLjnBzxyaMT\",\n        \"supply\": \"100\",\n        \"creators\": [\n          {\n            \"account\": \"ETHEREUM:0x2e2d91093341493d4722083e710110163c3be5b9\",\n            \"value\": 10000\n          }\n        ],\n        \"royalties\": [\n          {\n            \"account\": \"ETHEREUM:0x2e2d91093341493d4722083e710110163c3be5b9\",\n            \"value\": 2000\n          }\n        ],\n        \"signatures\": [\n          \"0xf822e8642be85a526f92c5bbec5af0550741c5d1b9b5b4ff2d83b424d2a47d1514254ec9667ded2fc74697758c013374456c7cd0879750e00097963ca08494481b\"\n        ]\n      },\n      \"value\": \"100\"\n    },\n    \"take\": {\n      \"type\": {\n        \"@type\": \"ETH\",\n        \"blockchain\": \"ETHEREUM\"\n      },\n      \"value\": \"9.1\"\n    },\n    \"salt\": \"0x28000d2f67a3eeed7cf0a2b85b559e71ba36a5837f8e1693f5f2355f1667adb6\",\n    \"signature\": \"0x51233898413883053f099e5e1ccac1418631a3108696c204aa91eb3024bcd4ed420e42f2fbdcb242a940a0fb0b697bcdb415d1269ed6507e4590cddb723c40d31c\",\n    \"data\": {\n      \"@type\": \"ETH_RARIBLE_V2\",\n      \"payouts\": [],\n      \"originFees\": [\n        {\n          \"account\": \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\",\n          \"value\": 250\n        }\n      ]\n    }\n  },\n  \"originOrders\": [],\n  \"ammOrders\": {\n    \"ids\": []\n  },\n  \"auctions\": [],\n  \"totalStock\": \"0\",\n  \"sellers\": 0\n}\n</code></pre> get All Items <p>Returns All Items</p> <p><code>https://api.rarible.org/v0.1/items/all</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/items/all?blockchains=POLYGON&amp;size=1'\n</code></pre> <p>Example response (status 200)</p> <pre><code>{\n  \"continuation\": \"1669016456510_POLYGON:0x22d5f9b75c524fec1d6619787e582644cd4d7422:208\",\n  \"items\": [\n    {\n      \"id\": \"POLYGON:0x22d5f9b75c524fec1d6619787e582644cd4d7422:208\",\n      \"blockchain\": \"POLYGON\",\n      \"collection\": \"POLYGON:0x22d5f9b75c524fec1d6619787e582644cd4d7422\",\n      \"contract\": \"POLYGON:0x22d5f9b75c524fec1d6619787e582644cd4d7422\",\n      \"tokenId\": \"208\",\n      \"creators\": [\n        {\n          \"account\": \"ETHEREUM:0x0e06f59f3737e7fe81a25c2332ddb1b164a0933b\",\n          \"value\": 10000\n        }\n      ],\n      \"lazySupply\": \"0\",\n      \"pending\": [],\n      \"mintedAt\": \"2022-02-28T21:05:45Z\",\n      \"lastUpdatedAt\": \"2022-11-21T07:40:56.510Z\",\n      \"supply\": \"2641228165888999997013728\",\n      \"meta\": {\n        \"name\": \"Parsnip\",\n        \"description\": \"\\r\\n## Parsnip\\r\\n\\r\\nA crop grown at Sunflower Land.\\r\\n\\r\\nNot to be mistaken for carrots.\\r\\n\\r\\n## Supply\\r\\n\\r\\nUnlimited\\r\\n\\r\\n[Link](https://docs.sunflower-land.com/player-guides/crop-farming)\",\n        \"tags\": [],\n        \"genres\": [],\n        \"originalMetaUri\": \"https://sunflower-land.com/play/erc1155/208.json\",\n        \"attributes\": [\n          {\n            \"key\": \"Purpose\",\n            \"value\": \"Crop\"\n          }\n        ],\n        \"content\": [\n          {\n            \"@type\": \"IMAGE\",\n            \"url\": \"https://sunflower-land.com/play/erc1155/images/208.png\",\n            \"representation\": \"ORIGINAL\",\n            \"mimeType\": \"image/png\",\n            \"size\": 5590,\n            \"available\": true,\n            \"width\": 400,\n            \"height\": 400\n          }\n        ],\n        \"restrictions\": []\n      },\n      \"deleted\": false,\n      \"bestSellOrder\": {\n        \"id\": \"POLYGON:0xf808f42f8fc3fb2b75ccc0767504634a5b16aacfd77d35b87314173607c8b70c\",\n        \"fill\": \"1000001\",\n        \"platform\": \"RARIBLE\",\n        \"status\": \"ACTIVE\",\n        \"makeStock\": \"8999999998999999\",\n        \"cancelled\": false,\n        \"optionalRoyalties\": false,\n        \"createdAt\": \"2022-10-30T06:43:45.313Z\",\n        \"lastUpdatedAt\": \"2022-11-20T14:50:37.506Z\",\n        \"dbUpdatedAt\": \"2022-11-20T15:15:09.753Z\",\n        \"makePrice\": \"0.00000000000000007\",\n        \"makePriceUsd\": \"0.000000000000000056967095449175135\",\n        \"maker\": \"ETHEREUM:0x0e27030eff636cf4f106bdba6a0808b15fec26a8\",\n        \"make\": {\n          \"type\": {\n            \"@type\": \"ERC1155\",\n            \"contract\": \"POLYGON:0x22d5f9b75c524fec1d6619787e582644cd4d7422\",\n            \"tokenId\": \"208\"\n          },\n          \"value\": \"9000000000000000\"\n        },\n        \"take\": {\n          \"type\": {\n            \"@type\": \"ETH\",\n            \"blockchain\": \"POLYGON\"\n          },\n          \"value\": \"0.63\"\n        },\n        \"salt\": \"0x773848ad047df6e1218da98aeb48af0e7cf3e3a36f20a59d1e0c3dccb0cf712b\",\n        \"signature\": \"0xf4c5de0cbb1d662148a169d985b57ccdd9a12e172f5f07f4757e2ae2065b26e83bd917785c8f8cb5926eea1eea61eb51281295314da280483874ab48d26073381b\",\n        \"data\": {\n          \"@type\": \"ETH_RARIBLE_V2\",\n          \"payouts\": [],\n          \"originFees\": [\n            {\n              \"account\": \"ETHEREUM:0x0f22f838aaca272afb0f268e4f4e655fac3a35ec\",\n              \"value\": 100\n            }\n          ]\n        }\n      },\n      \"originOrders\": [],\n      \"ammOrders\": {\n        \"ids\": []\n      },\n      \"auctions\": [],\n      \"totalStock\": \"13019738007818531\",\n      \"sellers\": 25,\n      \"lastSale\": {\n        \"date\": \"2022-11-20T22:58:51Z\",\n        \"seller\": \"ETHEREUM:0x2ed2c862c8a4a08f0aa0eb44457f913a9642d8a8\",\n        \"buyer\": \"ETHEREUM:0x9c8dd003954c9fad77e5eca97775b1cd808a3af5\",\n        \"value\": \"1000000000000000000\",\n        \"currency\": {\n          \"@type\": \"ETH\",\n          \"blockchain\": \"POLYGON\"\n        },\n        \"price\": \"0\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"reference/search-capabilities/#orders","title":"Orders","text":"get Order by Id <p>Returns Order by Id</p> <p><code>https://api.rarible.org/v0.1/orders/{id}</code></p> <p>Example request (mainnet)</p> <pre><code>    curl --request GET 'https://api.rarible.org/v0.1/orders/ETHEREUM:0x48371f4b1656fa02617945936ba701341cbf586ebebfd9a6d188758c5e8baa37'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>id</code> \u2014 order Id, has format <code>${blockchain}:${id}</code>. For example, <code>ETHEREUM:0x48371f4b1656fa02617945936ba701341cbf586ebebfd9a6d188758c5e8baa37</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"id\": \"ETHEREUM:0x48371f4b1656fa02617945936ba701341cbf586ebebfd9a6d188758c5e8baa37\",\n  \"fill\": \"0\",\n  \"platform\": \"X2Y2\",\n  \"status\": \"CANCELLED\",\n  \"startedAt\": \"2022-11-15T20:41:58Z\",\n  \"endedAt\": \"2022-12-15T20:40:49Z\",\n  \"makeStock\": \"0\",\n  \"cancelled\": true,\n  \"optionalRoyalties\": false,\n  \"createdAt\": \"2022-11-15T20:41:58Z\",\n  \"lastUpdatedAt\": \"2022-11-15T20:48:47Z\",\n  \"dbUpdatedAt\": \"2022-11-15T20:49:00.376Z\",\n  \"makePrice\": \"59.3\",\n  \"makePriceUsd\": \"64662.5109083251711\",\n  \"maker\": \"ETHEREUM:0xed2ab4948ba6a909a7751dec4f34f303eb8c7236\",\n  \"make\": {\n    \"type\": {\n      \"@type\": \"ERC721\",\n      \"contract\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n      \"tokenId\": \"6582\"\n    },\n    \"value\": \"1\"\n  },\n  \"take\": {\n    \"type\": {\n      \"@type\": \"ETH\",\n      \"blockchain\": \"ETHEREUM\"\n    },\n    \"value\": \"59.3\"\n  },\n  \"salt\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"data\": {\n    \"@type\": \"ETH_X2Y2_ORDER_DATA_V1\",\n    \"itemHash\": \"0x48371f4b1656fa02617945936ba701341cbf586ebebfd9a6d188758c5e8baa37\",\n    \"isCollectionOffer\": false,\n    \"isBundle\": false,\n    \"side\": 1,\n    \"orderId\": \"22856542\"\n  }\n}\n</code></pre> get Sell Orders by maker <p>Returns Sell Orders by maker</p> <p><code>https://api.rarible.org/v0.1/orders/sell/byMaker</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/orders/sell/byMaker?maker=ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb&amp;size=1'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>maker</code> \u2014 the maker of the order, has format <code>${blockchain}:${id}</code>. For example, <code>ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"continuation\": \"1650005167000_0xc4ecfd56430005afd1599582d3e176b4d8a899ffe19635c465f1d77a61887394\",\n  \"orders\": [\n    {\n      \"id\": \"ETHEREUM:0xc4ecfd56430005afd1599582d3e176b4d8a899ffe19635c465f1d77a61887394\",\n      \"fill\": \"0.000001\",\n      \"platform\": \"OPEN_SEA\",\n      \"status\": \"FILLED\",\n      \"startedAt\": \"2022-04-15T06:41:25Z\",\n      \"endedAt\": \"2022-05-15T06:41:11Z\",\n      \"makeStock\": \"0\",\n      \"cancelled\": false,\n      \"optionalRoyalties\": false,\n      \"createdAt\": \"2022-04-15T06:43:13.856Z\",\n      \"lastUpdatedAt\": \"2022-04-15T06:46:07Z\",\n      \"dbUpdatedAt\": \"2022-04-15T06:46:07Z\",\n      \"makePrice\": \"0.000001\",\n      \"makePriceUsd\": \"0.001090430200814927\",\n      \"maker\": \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\",\n      \"taker\": \"ETHEREUM:0xc0dbf125284240a768ad4ac1e2a2f20d77f6cfc8\",\n      \"make\": {\n        \"type\": {\n          \"@type\": \"ERC1155\",\n          \"contract\": \"ETHEREUM:0x495f947276749ce646f68ac8c248420045cb7b5e\",\n          \"tokenId\": \"103834860413964016633619762390589326621035685084276300587330675527037531193345\"\n        },\n        \"value\": \"1\"\n      },\n      \"take\": {\n        \"type\": {\n          \"@type\": \"ETH\",\n          \"blockchain\": \"ETHEREUM\"\n        },\n        \"value\": \"0.000001\"\n      },\n      \"salt\": \"0xa6cb012bbaeeacb79c4ea9e6670292434b08124ab672b8541f47a970e50bd329\",\n      \"signature\": \"0xc5418e2c254b7d81f7d429785380a2f0c6cc6e9c0be5e6fc4b2a8a83573c167a7789549f26b7922a4e66a895e2f63f17bafa052d704de592a95baf1a8e9709661c\",\n      \"data\": {\n        \"@type\": \"ETH_OPEN_SEA_V1\",\n        \"exchange\": \"ETHEREUM:0x7f268357a8c2552623316e2562d90e642bb538e5\",\n        \"makerRelayerFee\": \"1250\",\n        \"takerRelayerFee\": \"0\",\n        \"makerProtocolFee\": \"0\",\n        \"takerProtocolFee\": \"0\",\n        \"feeRecipient\": \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\",\n        \"feeMethod\": \"SPLIT_FEE\",\n        \"side\": \"SELL\",\n        \"saleKind\": \"FIXED_PRICE\",\n        \"howToCall\": \"DELEGATE_CALL\",\n        \"callData\": \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000495f947276749ce646f68ac8c248420045cb7b5ee59072c5084ec2dc16e6bcdc3560802ffbafb5cb0000000000000b00000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\",\n        \"replacementPattern\": \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        \"staticTarget\": \"ETHEREUM:0x0000000000000000000000000000000000000000\",\n        \"staticExtraData\": \"0x\",\n        \"extra\": \"0\"\n      }\n    }\n  ]\n}\n</code></pre> get All Orders <p>Returns all Orders</p> <p><code>https://api.rarible.org/v0.1/orders/all</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/orders/all?size=1'\n</code></pre> <p>Example response (status 200)</p> <pre><code>{\n    \"continuation\": \"ETHEREUM:1648132257821_0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\",\n    \"orders\": [\n        {\n            \"id\": \"ETHEREUM:0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\",\n            \"fill\": \"0\",\n            \"platform\": \"RARIBLE\",\n            \"status\": \"ACTIVE\",\n            \"makeStock\": \"1\",\n            \"cancelled\": false,\n            \"createdAt\": \"2022-03-24T14:30:57.821Z\",\n            \"lastUpdatedAt\": \"2022-03-24T14:30:57.821Z\",\n            \"makePrice\": \"0.01\",\n            \"makePriceUsd\": \"30.198384450784797\",\n            \"priceHistory\": [\n                {\n                    \"date\": \"2022-03-24T14:30:57.821Z\",\n                    \"makeValue\": \"1\",\n                    \"takeValue\": \"0.01\"\n                }\n            ],\n            \"maker\": \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\",\n            \"make\": {\n                \"type\": {\n                    \"@type\": \"ERC721_Lazy\",\n                    \"contract\": \"ETHEREUM:0x6110ea0489c929b44152e99c133e17025a684223\",\n                    \"tokenId\": \"29022402683878927866272288177291204022157824894707812777715415655733163720747\",\n                    \"uri\": \"/ipfs/Qmb37SGcSV3ELHeZSzcZt5ymERUn9ug5vtqmPQfs7yFQUm\",\n                    \"creators\": [\n                        {\n                            \"account\": \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\",\n                            \"value\": 10000\n                        }\n                    ],\n                    \"royalties\": [\n                        {\n                            \"account\": \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\",\n                            \"value\": 1000\n                        }\n                    ],\n                    \"signatures\": [\n                        \"0x60647533cdabee46b8e40b19cfcc588585d306ce061ddaf50e5dc8187ea6e0e955e91ef1d61a4cbf17dc81136bdadccf6052d54791fa3dbad65bd5925932e7191c\"\n                    ]\n                },\n                \"value\": \"1\"\n            },\n            \"take\": {\n                \"type\": {\n                    \"@type\": \"ETH\",\n                    \"blockchain\": \"ETHEREUM\"\n                },\n                \"value\": \"0.01\"\n            },\n            \"salt\": \"0x4605d2c0a64793ea84b6b58edf2326356d5562eeeb4e550f2b79bb965f984ac4\",\n            \"signature\": \"0xd67ffbe94321dce166ff3028546914547a9f6d44ba434db20e0244f83626862e41606a1254f5c7565bce88ae78d7f5f0214553b6dd6d5cd4f9198302d5c1fa781c\",\n            \"pending\": [],\n            \"data\": {\n                \"@type\": \"ETH_RARIBLE_V2\",\n                \"payouts\": [],\n                \"originFees\": [\n                    {\n                        \"account\": \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\",\n                        \"value\": 250\n                    }\n                ]\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/search-capabilities/#collections","title":"Collections","text":"get Collections by owner <p>Returns Collections by owner</p> <p><code>https://api.rarible.org/v0.1/collections/byOwner</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/collections/byOwner?owner=ETHEREUM:0x5a019874f4fae314b0eaa4606be746366e661306'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>owner</code> \u2014 address of the collection owner, has format <code>${blockchain}:${address}</code>. For example, <code>ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"total\": 1,\n  \"continuation\": \"1669113675427_3961628903332964660\",\n  \"collections\": [\n    {\n      \"id\": \"ETHEREUM:0x8a90cab2b38dba80c64b7734e58ee1db38b8992e\",\n      \"blockchain\": \"ETHEREUM\",\n      \"type\": \"ERC721\",\n      \"status\": \"CONFIRMED\",\n      \"name\": \"Doodles\",\n      \"symbol\": \"DOODLE\",\n      \"owner\": \"ETHEREUM:0x5a019874f4fae314b0eaa4606be746366e661306\",\n      \"features\": [\n        \"APPROVE_FOR_ALL\"\n      ],\n      \"minters\": [],\n      \"meta\": {\n        \"name\": \"Doodles\",\n        \"description\": \"A community-driven collectibles project featuring art by Burnt Toast. Doodles come in a joyful range of colors, traits and sizes with a collection size of 10,000. Each Doodle allows its owner to vote for experiences and activations paid for by the Doodles Community Treasury.\",\n        \"tags\": [],\n        \"genres\": [],\n        \"externalUri\": \"https://doodles.app\",\n        \"content\": [\n          {\n            \"@type\": \"IMAGE\",\n            \"url\": \"https://i.seadn.io/gae/7B0qai02OdHA8P_EOVK672qUliyjQdQDGNrACxs7WnTgZAkJa_wWURnIFKeOh5VTf8cfTqW3wQpozGedaC9mteKphEOtztls02RlWQ?w=500&amp;auto=format\",\n            \"representation\": \"ORIGINAL\"\n          }\n        ],\n        \"externalLink\": \"https://doodles.app\",\n        \"sellerFeeBasisPoints\": 250,\n        \"feeRecipient\": \"ETHEREUM:0xd1f124cc900624e1ff2d923180b3924147364380\"\n      },\n      \"bestBidOrder\": {\n        \"id\": \"ETHEREUM:0xd8768764825b1579a7564aa53c2ae6ff35b11264753bb7996d8a3783dd622d6c\",\n        \"fill\": \"0\",\n        \"platform\": \"RARIBLE\",\n        \"status\": \"ACTIVE\",\n        \"endedAt\": \"2023-02-11T10:14:45Z\",\n        \"makeStock\": \"1.21\",\n        \"cancelled\": false,\n        \"optionalRoyalties\": false,\n        \"createdAt\": \"2022-11-13T10:14:56.695Z\",\n        \"lastUpdatedAt\": \"2022-11-19T20:04:47Z\",\n        \"dbUpdatedAt\": \"2022-11-19T20:04:54.528Z\",\n        \"takePrice\": \"1.21\",\n        \"takePriceUsd\": \"1356.514677472391657\",\n        \"maker\": \"ETHEREUM:0x77c0c1c3d55a9afad3ad19f231259cf78a203a8d\",\n        \"make\": {\n          \"type\": {\n            \"@type\": \"ERC20\",\n            \"contract\": \"ETHEREUM:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n          },\n          \"value\": \"1.21\"\n        },\n        \"take\": {\n          \"type\": {\n            \"@type\": \"COLLECTION\",\n            \"contract\": \"ETHEREUM:0x8a90cab2b38dba80c64b7734e58ee1db38b8992e\"\n          },\n          \"value\": \"1\"\n        },\n        \"salt\": \"0x813278fe4ebd6335b4333a80497738c1f38996e0b315ce812ad421c54d47dd23\",\n        \"signature\": \"0x4371588e8b5ed0331fe24e72f4a411a6c2eb231728096b15c34b7694ca400e2c1f2c53f6d43a99e56258619d3e7d5342b4ef876d49384c19b005edb851a3a8591c\",\n        \"data\": {\n          \"@type\": \"ETH_RARIBLE_V2\",\n          \"payouts\": [],\n          \"originFees\": [\n            {\n              \"account\": \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\",\n              \"value\": 100\n            }\n          ]\n        }\n      },\n      \"originOrders\": [],\n      \"statistics\": {\n        \"ownerCount\": 5582,\n        \"itemCount\": 5582,\n        \"ownerCountTotal\": \"10000\",\n        \"itemCountTotal\": \"5582\",\n        \"highestSale\": {\n          \"value\": \"296.4807216419148\",\n          \"valueUsd\": \"1110196.5062220949\"\n        },\n        \"totalVolume\": {\n          \"value\": \"207022.60851323992\",\n          \"valueUsd\": \"583735118.8325903\"\n        },\n        \"volumes\": [\n          {\n            \"period\": \"DAY\",\n            \"value\": {\n              \"value\": \"7.8\",\n              \"valueUsd\": \"10007.35639766455\"\n            },\n            \"changePercent\": \"-83.04460747884089\"\n          },\n          {\n            \"period\": \"WEEK\",\n            \"value\": {\n              \"value\": \"293.64456980127034\",\n              \"valueUsd\": \"378942.51244305656\"\n            },\n            \"changePercent\": \"-22.766684857781108\"\n          },\n          {\n            \"period\": \"MONTH\",\n            \"value\": {\n              \"value\": \"1520.5154496508244\",\n              \"valueUsd\": \"2029754.9444540597\"\n            },\n            \"changePercent\": \"-54.72143141310838\"\n          }\n        ],\n        \"floorPrice\": {\n          \"value\": \"7.69\",\n          \"valueUsd\": \"10050.134755031484\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> get Collection by Id <p>Returns Collection by Id</p> <p><code>https://api.rarible.org/v0.1/collections/{collection}</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/collections/POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>collection</code> \u2014 collection address, has format <code>${blockchain}:${address}</code>. For example, <code>POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"id\": \"POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7\",\n  \"blockchain\": \"POLYGON\",\n  \"type\": \"ERC721\",\n  \"status\": \"CONFIRMED\",\n  \"name\": \"LUCA\",\n  \"symbol\": \"InvoiceNFT\",\n  \"owner\": \"ETHEREUM:0x00000000007b9543f6fea6a20fd440b050db3ea0\",\n  \"features\": [\n    \"APPROVE_FOR_ALL\"\n  ],\n  \"minters\": [],\n  \"meta\": {\n    \"name\": \"Untitled\",\n    \"tags\": [],\n    \"genres\": [],\n    \"content\": []\n  },\n  \"originOrders\": []\n}\n</code></pre> get All Collections <p>Returns all Collections</p> <p><code>https://api.rarible.org/v0.1/collections/all</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&amp;size=1'\n</code></pre> <p>Example response (status 200)</p> <pre><code>{\n    \"total\": 1,\n    \"continuation\": \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\",\n    \"collections\": [\n        {\n            \"id\": \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\",\n            \"blockchain\": \"ETHEREUM\",\n            \"type\": \"ERC721\",\n            \"name\": \"Test\",\n            \"symbol\": \"TEST\",\n            \"owner\": \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\",\n            \"features\": [\n                \"APPROVE_FOR_ALL\"\n            ],\n            \"minters\": [],\n            \"meta\": {\n                \"name\": \"Untitled\",\n                \"content\": []\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/search-capabilities/#ownerships","title":"Ownerships","text":"get Ownerships by Item <p>Returns Ownerships by Item</p> <p><code>https://api.rarible.org/v0.1/ownerships/byItem</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/ownerships/byItem?itemId=ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:390'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>itemId</code> \u2014 Id of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code>. For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"continuation\": \"1668748561355_ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:390:0xba26877c2036e1f2baba63bdd5bfe996b050e13c\",\n  \"ownerships\": [\n    {\n      \"id\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:390:0xba26877c2036e1f2baba63bdd5bfe996b050e13c\",\n      \"blockchain\": \"ETHEREUM\",\n      \"itemId\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:390\",\n      \"contract\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n      \"collection\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n      \"tokenId\": \"390\",\n      \"owner\": \"ETHEREUM:0xba26877c2036e1f2baba63bdd5bfe996b050e13c\",\n      \"value\": \"1\",\n      \"createdAt\": \"2022-11-18T05:16:01.355Z\",\n      \"lastUpdatedAt\": \"2022-11-18T05:16:02.377Z\",\n      \"creators\": [],\n      \"lazyValue\": \"0\",\n      \"pending\": [],\n      \"bestSellOrder\": {\n        \"id\": \"ETHEREUM:0x87301d558f0863ddc43f6200d76cb28bcdf2c292691c8ed37b5ae0c29842d2fd\",\n        \"fill\": \"0\",\n        \"platform\": \"LOOKSRARE\",\n        \"status\": \"ACTIVE\",\n        \"startedAt\": \"2022-11-22T01:13:35Z\",\n        \"endedAt\": \"2022-11-23T01:13:35Z\",\n        \"makeStock\": \"1\",\n        \"cancelled\": false,\n        \"optionalRoyalties\": false,\n        \"createdAt\": \"2022-11-22T01:13:35Z\",\n        \"lastUpdatedAt\": \"2022-11-22T01:13:35Z\",\n        \"dbUpdatedAt\": \"2022-11-22T01:15:36.700Z\",\n        \"makePrice\": \"61.2\",\n        \"makePriceUsd\": \"68454.63864745771392\",\n        \"maker\": \"ETHEREUM:0xba26877c2036e1f2baba63bdd5bfe996b050e13c\",\n        \"make\": {\n          \"type\": {\n            \"@type\": \"ERC721\",\n            \"contract\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n            \"tokenId\": \"390\"\n          },\n          \"value\": \"1\"\n        },\n        \"take\": {\n          \"type\": {\n            \"@type\": \"ETH\",\n            \"blockchain\": \"ETHEREUM\"\n          },\n          \"value\": \"61.2\"\n        },\n        \"salt\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"signature\": \"0x4774e21e5a4117c26f7d47bdf8d2e860291ae72856fca7953e24ee413a0c3d556a6c0ce7ff22ea4c344b45bfcafc29bf5c7bff9641f5c7ff672566ed56dd11821b\",\n        \"data\": {\n          \"@type\": \"ETH_LOOKSRARE_ORDER_DATA_V1\",\n          \"minPercentageToAsk\": 9800,\n          \"strategy\": \"ETHEREUM:0x579af6fd30bf83a5ac0d636bc619f98dbdeb930c\",\n          \"nonce\": 169\n        }\n      },\n      \"originOrders\": []\n    }\n  ]\n}\n</code></pre> get Ownerships by Id <p>Returns Ownerships by Id</p> <p><code>https://api.rarible.org/v0.1/ownerships/{ownershipId}</code></p> <p>Example request (mainnet)</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/ownerships/ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:390:0xba26877c2036e1f2baba63bdd5bfe996b050e13c'\n</code></pre> <p>Request parameters:</p> <ul> <li><code>ownershipId</code> \u2014 ownership Id in format <code>${blockchain}:${token}:${tokenId}:${owner}</code>. For example, <code>ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3</code></li> </ul> <p>Example response (status 200)</p> <pre><code>{\n  \"id\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:390:0xba26877c2036e1f2baba63bdd5bfe996b050e13c\",\n  \"blockchain\": \"ETHEREUM\",\n  \"itemId\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:390\",\n  \"contract\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n  \"collection\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n  \"tokenId\": \"390\",\n  \"owner\": \"ETHEREUM:0xba26877c2036e1f2baba63bdd5bfe996b050e13c\",\n  \"value\": \"1\",\n  \"createdAt\": \"2022-11-18T05:16:01.355Z\",\n  \"lastUpdatedAt\": \"2022-11-18T05:16:02.377Z\",\n  \"creators\": [],\n  \"lazyValue\": \"0\",\n  \"pending\": [],\n  \"bestSellOrder\": {\n    \"id\": \"ETHEREUM:0x87301d558f0863ddc43f6200d76cb28bcdf2c292691c8ed37b5ae0c29842d2fd\",\n    \"fill\": \"0\",\n    \"platform\": \"LOOKSRARE\",\n    \"status\": \"ACTIVE\",\n    \"startedAt\": \"2022-11-22T01:13:35Z\",\n    \"endedAt\": \"2022-11-23T01:13:35Z\",\n    \"makeStock\": \"1\",\n    \"cancelled\": false,\n    \"optionalRoyalties\": false,\n    \"createdAt\": \"2022-11-22T01:13:35Z\",\n    \"lastUpdatedAt\": \"2022-11-22T01:13:35Z\",\n    \"dbUpdatedAt\": \"2022-11-22T01:15:36.700Z\",\n    \"makePrice\": \"61.2\",\n    \"makePriceUsd\": \"68454.63864745771392\",\n    \"maker\": \"ETHEREUM:0xba26877c2036e1f2baba63bdd5bfe996b050e13c\",\n    \"make\": {\n      \"type\": {\n        \"@type\": \"ERC721\",\n        \"contract\": \"ETHEREUM:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\",\n        \"tokenId\": \"390\"\n      },\n      \"value\": \"1\"\n    },\n    \"take\": {\n      \"type\": {\n        \"@type\": \"ETH\",\n        \"blockchain\": \"ETHEREUM\"\n      },\n      \"value\": \"61.2\"\n    },\n    \"salt\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"signature\": \"0x4774e21e5a4117c26f7d47bdf8d2e860291ae72856fca7953e24ee413a0c3d556a6c0ce7ff22ea4c344b45bfcafc29bf5c7bff9641f5c7ff672566ed56dd11821b\",\n    \"data\": {\n      \"@type\": \"ETH_LOOKSRARE_ORDER_DATA_V1\",\n      \"minPercentageToAsk\": 9800,\n      \"strategy\": \"ETHEREUM:0x579af6fd30bf83a5ac0d636bc619f98dbdeb930c\",\n      \"nonce\": 169\n    }\n  },\n  \"originOrders\": []\n}\n</code></pre>"},{"location":"reference/search-capabilities/#activity","title":"Activity","text":"<p>We have several query parameters for paging and continuation in the Activity controller methods:</p> <ul> <li><code>size</code> \u2014 the maximum number of results per page to return</li> <li><code>continuation</code> \u2014 deprecated parameter</li> <li><code>cursor</code> \u2014 combined continuation token from the previous response, type of page token. Can be used to get the next page of results in a subsequent list request. Has format <code>${BLOCKCHAIN}:${TS_MS}_{ENTITY_ID};...</code>, where:<ul> <li><code>BLOCKCHAIN</code> \u2014 blockchain name: <code>ETHEREUM</code>, <code>FLOW</code>, <code>TEZOS</code>, <code>POLYGON</code> or <code>SOLANA</code></li> <li><code>TS_MS</code> \u2014 timestamp of the <code>data</code> in ms</li> <li><code>ENTITY_ID</code> \u2014 entity identifier, different blockchains have different identifier formats</li> </ul> </li> </ul> <p>For example:</p> <pre><code>POLYGON:1649395092000_624fc5956f6dc654e6095b90;ETHEREUM:1649395762000_624fc83a63c052298d2e2b61;SOLANA:1649395777000_000126563148:EjGVpJkNpjCakf5WcN13b8rZzxvDAnjVm7mgLam812xm:000185:4fGmEP5Cm3MURsGJ8mx1uEC7c2sWsVrAGdjC2PfCbamj5ZKZwwCRYTUWyoY3Yzo3JYr5TGqJEUnmB6ejFPChTNKJ:000000:000001;TEZOS:1649260825000_BMQpZgFjvunjfqe7JPbRihLxrAv89vR9wtaHBpf8H6FULqXQM6o_243;FLOW:1649159220612_a4a4ad0e64aa0a3e6820f8a546d9355045eb1ca2f4818b85f5c0085f8cae04b9.64\n</code></pre> <p>If the blockchain is not specified in the <code>cursor</code>, then no entries have been found for it according to the sorting results.</p> <p>To get the next page of results, set <code>cursor</code> returned by a previous list request. But we recommend using the cursor in automated mode, because it is not designed to be built by hand.</p> <p>If you still want to use it manually, use the following example to get the correct data.</p> getAllActivities example <p><code>https://api.rarible.org/v0.1/activities/all</code></p> <ol> <li> <p>Specify the query parameters: <code>blockchains</code>, activity <code>type</code>, and <code>size</code>:</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&amp;type=MINT&amp;size=3'\n</code></pre> <p>Example response (status 200)</p> <pre><code>{\n    \"continuation\": \"1649398291000_624fd21b63c052298d2e43f9\",\n    \"cursor\": \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\",\n    \"activities\": [\n        {\n            \"@type\": \"MINT\",\n            \"id\": \"ETHEREUM:624fd23963c052298d2e4407\",\n            \"date\": \"2022-04-08T06:12:02Z\",\n            \"reverted\": false,\n            \"owner\": \"ETHEREUM:0x33b5606763150120076308076c91f01132a799da\",\n            \"contract\": \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310\",\n            \"tokenId\": \"2\",\n            \"itemId\": \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310:2\",\n            \"value\": \"1\",\n            \"transactionHash\": \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\",\n            \"blockchainInfo\": {\n                \"transactionHash\": \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\",\n                \"blockHash\": \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\",\n                \"blockNumber\": 10467061,\n                \"logIndex\": 21\n            }\n        },\n        {\n            \"@type\": \"MINT\",\n            \"id\": \"ETHEREUM:624fd23963c052298d2e4406\",\n            \"date\": \"2022-04-08T06:12:02Z\",\n            \"reverted\": false,\n            \"owner\": \"ETHEREUM:0xd4f6cb0c1fe07407b7098ac7fe4265f3b2ae61f2\",\n            \"contract\": \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18\",\n            \"tokenId\": \"1\",\n            \"itemId\": \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18:1\",\n            \"value\": \"1\",\n            \"transactionHash\": \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\",\n            \"blockchainInfo\": {\n                \"transactionHash\": \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\",\n                \"blockHash\": \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\",\n                \"blockNumber\": 10467061,\n                \"logIndex\": 0\n            }\n        },\n        {\n            \"@type\": \"MINT\",\n            \"id\": \"ETHEREUM:624fd21b63c052298d2e43f9\",\n            \"date\": \"2022-04-08T06:11:31Z\",\n            \"reverted\": false,\n            \"owner\": \"ETHEREUM:0x739cc4746e106d050f757bcece2aafc9f2eaaa28\",\n            \"contract\": \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982\",\n            \"tokenId\": \"10\",\n            \"itemId\": \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982:10\",\n            \"value\": \"1\",\n            \"transactionHash\": \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\",\n            \"blockchainInfo\": {\n                \"transactionHash\": \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\",\n                \"blockHash\": \"0xe5b01f69dba978cb52907a6d12938550fcab5bac1572c9d7ca5c7fab30d32c84\",\n                \"blockNumber\": 10467059,\n                \"logIndex\": 6\n            }\n        }\n    ]\n}\n</code></pre> <p>As we see, <code>ENTITY_ID</code> part in the <code>cursor</code> is the same as <code>id</code> of the last element in the response:</p> <pre><code>{\n    ...\n    \"cursor\": \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\",\n    \"activities\": [\n        {\n        ...\n        {\n            ...\n            \"id\": \"ETHEREUM:624fd21b63c052298d2e43f9\",\n            ...\n            }\n        }\n    ]\n}\n</code></pre> </li> <li> <p>Take the resulting <code>cursor</code> and add it to the new query:</p> <pre><code>curl --request GET 'https://api.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&amp;type=MINT&amp;cursor=ETHEREUM:1649398291000_624fd21b63c052298d2e43f9&amp;size=3'\n</code></pre> <p>Example response (status 200)</p> <pre><code>{\n    \"cursor\": \"ETHEREUM:1649398276000_624fd20e63c052298d2e42f6\",\n    \"activities\": [\n        {\n            \"@type\": \"MINT\",\n            \"id\": \"ETHEREUM:624fd20f63c052298d2e43e3\",\n            \"date\": \"2022-04-08T06:11:16Z\",\n            \"reverted\": false,\n            \"owner\": \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\",\n            \"contract\": \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\",\n            \"tokenId\": \"1011\",\n            \"itemId\": \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1011\",\n            \"value\": \"1\",\n            \"transactionHash\": \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\",\n            \"blockchainInfo\": {\n                \"transactionHash\": \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\",\n                \"blockHash\": \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\",\n                \"blockNumber\": 10467058,\n                \"logIndex\": 508\n            }\n        },\n        {\n            \"@type\": \"MINT\",\n            \"id\": \"ETHEREUM:624fd20f63c052298d2e43e2\",\n            \"date\": \"2022-04-08T06:11:16Z\",\n            \"reverted\": false,\n            \"owner\": \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\",\n            \"contract\": \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\",\n            \"tokenId\": \"1012\",\n            \"itemId\": \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1012\",\n            \"value\": \"1\",\n            \"transactionHash\": \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\",\n            \"blockchainInfo\": {\n                \"transactionHash\": \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\",\n                \"blockHash\": \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\",\n                \"blockNumber\": 10467058,\n                \"logIndex\": 507\n            }\n        },\n        {\n            \"@type\": \"MINT\",\n            \"id\": \"ETHEREUM:624fd20e63c052298d2e42f6\",\n            \"date\": \"2022-04-08T06:11:16Z\",\n            \"reverted\": false,\n            \"owner\": \"ETHEREUM:0x0ade6d84cb1b8fe9ab8c8145f53b202c426a34f3\",\n            \"contract\": \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9\",\n            \"tokenId\": \"2\",\n            \"itemId\": \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9:2\",\n            \"value\": \"1\",\n            \"transactionHash\": \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\",\n            \"blockchainInfo\": {\n                \"transactionHash\": \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\",\n                \"blockHash\": \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\",\n                \"blockNumber\": 10467058,\n                \"logIndex\": 17\n            }\n        }\n    ]\n}\n</code></pre> </li> </ol> <p>Repeat this step with the newly obtained <code>cursor</code>, if necessary.</p> <p>On the multichain-api.rarible.org you can find more information about Protocol Multichain API.</p>"},{"location":"reference/transfer/","title":"Transfer","text":"<p>You can transfer NFTs with Rarible Multichain Protocol in different blockchains.</p> <p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"reference/transfer/#transfer-nfts","title":"Transfer NFTs","text":"<p>Use <code>transferItem</code> function:</p> <pre><code>import { createRaribleSdk } from \"@rarible/sdk\"\nimport { toItemId, toUnionAddress } from \"@rarible/types\"\nimport type { BlockchainWallet } from \"@rarible/sdk-wallet/src\"\n\nasync function transferItem(wallet: BlockchainWallet) {\n    const sdk = createRaribleSdk(wallet, \"dev\")\n    const transferAction = await sdk.nft.transfer({\n        itemId: toItemId(\"&lt;YOUR_ITEM_ID&gt;\"),\n    })\n    const tx = await transferAction.submit({\n        to: toUnionAddress(\"&lt;ITEM_RECIPIENT&gt;\"),\n        amount: 1,\n    })\n    await tx.wait()\n}\n</code></pre> <ul> <li><code>itemId</code> \u2014  Id of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code>. For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></li> <li><code>to</code> \u2014 address in Union format <code>${blockchainGroup}:${token}</code>. For example, <code>TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh</code></li> <li><code>amount</code> \u2014 amount of NFT tokens</li> </ul>"},{"location":"reference/transfer/#checking-transferred-nft","title":"Checking transferred NFT","text":"<p>To check the transferred item:</p> <ul> <li> <p>Use the <code>getItemById</code> API method</p> getItemById <p>Returns Item by ID.</p> <p><code>https://api.rarible.org/v0.1/items/{itemId}</code></p> <p>Example request (staging)</p> <pre><code>curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243'\n</code></pre> <p>Request parameters:</p> <ul> <li> <p><code>itemId</code> \u2014  ItemID of your NFT, has format <code>${blockchain}:${token}:${tokenId}</code></p> <p>For example, <code>ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345</code></p> </li> </ul> <p>Example response (status 200)</p> <pre><code>{\n   \"id\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\",\n   \"blockchain\": \"ETHEREUM\",\n   \"collection\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n   \"contract\": \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n   \"tokenId\": \"19661880631107248865491477079747186145992059189823053172927066273904580362243\",\n   \"creators\": [\n      {\n         \"account\": \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\",\n         \"value\": 10000\n      }\n   ],\n   \"owners\": [],\n   \"royalties\": [],\n   \"lazySupply\": \"0\",\n   \"pending\": [],\n   \"mintedAt\": \"2022-03-09T22:48:33Z\",\n   \"lastUpdatedAt\": \"2022-03-09T22:50:03.530Z\",\n   \"supply\": \"1\",\n   \"meta\": {\n      \"name\": \"gbgbgbgbgbgb\",\n      \"description\": \"\",\n      \"attributes\": [],\n      \"content\": [\n         {\n            \"@type\": \"IMAGE\",\n            \"url\": \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\",\n            \"representation\": \"ORIGINAL\",\n            \"mimeType\": \"image/jpeg\",\n            \"size\": 13311,\n            \"width\": 640,\n            \"height\": 640\n         }\n      ],\n      \"restrictions\": []\n   },\n   \"deleted\": false,\n   \"auctions\": [],\n   \"totalStock\": \"0\",\n   \"sellers\": 0\n}\n</code></pre> </li> <li> <p>Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos.</p> </li> </ul> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>"},{"location":"reference/wallets/","title":"Wallets initialization","text":"<p>To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Initialize wallets for used blockchains or use Rarible Wallet Connector (in general for frontend). It is possible to use SDK without wallet (for ex. <code>sdk.balances.getBalance</code>), but in that case you can't send transactions and sign messages:</p> <pre><code>const raribleSdk = createRaribleSdk(undefined, \"prod\")\n</code></pre>"},{"location":"reference/wallets/#initialize-simple-wallets","title":"Initialize simple wallets","text":"<ul> <li> <p>Ethereum / Polygon</p> <p>You can create EthereumWallet with one of the following providers:</p> <ul> <li>Web3 instance. For example, Metamask (<code>window.ethereum</code>) or HDWalletProvider</li> <li>ethers.providers.Web3Provider</li> <li>ethers.Wallet</li> </ul> <pre><code>import Web3 from \"web3\"\nimport * as HDWalletProvider from \"@truffle/hdwallet-provider\"\nimport { Web3Ethereum } from \"@rarible/web3-ethereum\"\nimport { ethers } from \"ethers\"\nimport { EthersEthereum, EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\"\nimport { EthereumWallet } from \"@rarible/sdk-wallet\"\n\n// if using another browser provider (not HD Wallet Provider), you will need to make a connection\nawait provider.request({ method: \"eth_requestAccounts\" })\n\n// creating EthereumWallet with Web3\nconst web3 = new Web3(provider)\nconst web3Ethereum = new Web3Ethereum({ web3 })\nconst ethWallet = new EthereumWallet(web3Ethereum)\n\n// or with HDWalletProvider\nconst provider = new HDWalletProvider({\n  url: \"&lt;NODE_URL&gt;\",\n  privateKeys: [\"0x0...\"],\n  chainId: 1,\n})\nconst web3 = new Web3(provider)\nconst web3Ethereum = new Web3Ethereum({ web3 })\nconst ethWallet = new EthereumWallet(web3Ethereum)\n\n// creating EthereumWallet with ethers.providers.Web3Provider\nconst ethersWeb3Provider = new ethers.providers.Web3Provider(provider)\nconst ethersProvider = new EthersWeb3ProviderEthereum(ethersWeb3Provider)\nconst ethWallet = new EthereumWallet(ethersProvider)\n\n// creating EthereumWallet with ethers.Wallet\nconst ethersWeb3Provider = new ethers.providers.Web3Provider(provider)\nconst ethersProvider = new EthersEthereum(new ethers.Wallet(wallet.getPrivateKeyString(), ethersWeb3Provider))\nconst ethWallet = new EthereumWallet(ethersProvider)\n\n// Second parameter \u2014 is environment: \"prod\" | \"staging\" | \"dev\"\nconst raribleSdk = createRaribleSdk(ethWallet, \"staging\")\n</code></pre> </li> <li> <p>Flow</p> <pre><code>import * as fcl from \"@onflow/fcl\"\nimport { FlowWallet } from \"@rarible/sdk-wallet\"\n\nconst wallet =  new FlowWallet(fcl)\n</code></pre> <p>You also need to configure Flow Client Library (FCL), because Flow-sdk use @onflow/fcl-js:</p> <pre><code>//example config for testnet\nimport { config } from \"@onflow/fcl\";\nconfig({\n  \"accessNode.api\": \"https://access-testnet.onflow.org\", // Mainnet: \"https://access-mainnet-beta.onflow.org\"\n  \"discovery.wallet\": \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\"\n})\n</code></pre> <p>See more configuration details on Flow documentation.</p> </li> <li> <p>Tezos</p> <p>To initialize wallets, you can use:</p> <ul> <li>in_memory_provider (also for backend)</li> <li>beacon_provider (@rarible/tezos-sdk/dist/providers/beacon/beacon_provider)</li> </ul> <pre><code>//in_memory_provider usage example\nimport { in_memory_provider } from \"@rarible/tezos-sdk/dist/providers/in_memory/in_memory_provider\"\nimport { TezosWallet } from \"@rarible/sdk-wallet\"\n\nconst provider = in_memory_provider(\"edsk...\", nodeUrl)\nconst wallet = new TezosWallet(provider)\n</code></pre> </li> <li> <p>Immutablex</p> <pre><code>import { ImxWallet } from \"@rarible/immutable-wallet\"\nimport { ImmutableXWallet } from \"@rarible/sdk-wallet\"\n\nconst imxConnectorWallet = new ImxWallet(\"dev\")\nawait imxConnectorWallet.connect()\nconst wallet = new ImmutableXWallet(imxConnectorWallet)\n</code></pre> </li> </ul>"},{"location":"reference/wallets/#wallet-connector","title":"Wallet Connector","text":"<p>It is better to use Wallet Connector because there is a lot of the logic described above already implemented and the connect function for each blockchain is unified.</p>"},{"location":"reference/wallets/#install","title":"Install","text":"<p>Yarn <pre><code>    yarn add @rarible/connector\n    # optional: add additional connectors\n    yarn add @rarible/connector-walletconnect\n    yarn add @rarible/connector-fortmatic\n    # check other @rarible/connector-* packages to see what's supported \n</code></pre></p> <p>NPM <pre><code>    npm i @rarible/connector\n    # optional: add additional connectors\n    npm i @rarible/connector-walletconnect\n    npm i @rarible/connector-fortmatic\n    # check other @rarible/connector-* packages to see what's supported \n</code></pre></p>"},{"location":"reference/wallets/#usage","title":"Usage","text":"<p>Create <code>Connector</code>, add all needed <code>ConnectionProvider's</code></p> <pre><code>import { Connector, InjectedWeb3ConnectionProvider, DappType } from \"@rarible/connector\"\nimport { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\"\n\n// create providers with the required options\nconst injected = new InjectedWeb3ConnectionProvider()\nconst walletConnect = new WalletConnectConnectionProvider()\n\n// create connector and push providers to it \nconst connector = Connector\n    .create([injected, walletConnect])\n\n// subscribe to connection status\nconnector.connection.subscribe((con) =&gt;\n    console.log(\"connection: \" + JSON.stringify(con))\n)\n\nconst options = await connector.getOptions(); // get list of available option\nawait connector.connect(options[0]); // connect to selected provider\n</code></pre>"},{"location":"reference/wallets/#usage-with-rarible-sdk","title":"Usage with Rarible SDK","text":"<pre><code>import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\"\nimport Web3 from \"web3\"\nimport { BlockchainWallet, FlowWallet, TezosWallet, EthereumWallet } from \"@rarible/sdk-wallet\"\nimport { Web3Ethereum } from \"@rarible/web3-ethereum\"\nimport {\n    Connector,\n    IConnectorStateProvider,\n    ConnectionProvider,\n    InjectedWeb3ConnectionProvider,\n    AbstractConnectionProvider,\n    EthereumProviderConnectionResult,\n} from \"@rarible/connector\"\nimport { FclConnectionProvider, FlowProviderConnectionResult } from \"@rarible/connector-fcl\"\nimport { MEWConnectionProvider } from \"@rarible/connector-mew\"\nimport { BeaconConnectionProvider, TezosProviderConnectionResult } from \"@rarible/connector-beacon\"\nimport { TorusConnectionProvider } from \"@rarible/connector-torus\"\nimport { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\"\nimport { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\"\nimport { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\"\nimport { PortisConnectionProvider } from \"@rarible/connector-portis\"\n\n\nconst ethereumRpcMap: Record&lt;number, string&gt; = {\n    1: \"https://node-mainnet.rarible.com\",\n    3: \"https://node-ropsten.rarible.com\",\n    4: \"https://node-rinkeby.rarible.com\",\n    17: \"https://node-e2e.rarible.com\",\n}\n\nexport type WalletAndAddress = {\n    wallet: BlockchainWallet\n    address: string\n}\n\nfunction mapEthereumWallet&lt;O&gt;(provider: AbstractConnectionProvider&lt;O, EthereumProviderConnectionResult&gt;): ConnectionProvider&lt;O, WalletAndAddress&gt; {\n    return provider.map(state =&gt; ({\n        wallet: new EthereumWallet(new Web3Ethereum({ web3: new Web3(state.provider), from: state.address })),\n        address: state.address\n    }))\n}\n\nfunction mapFlowWallet&lt;O&gt;(provider: AbstractConnectionProvider&lt;O, FlowProviderConnectionResult&gt;): ConnectionProvider&lt;O, WalletAndAddress&gt; {\n    return provider.map(state =&gt; ({\n        wallet: new FlowWallet(state.fcl),\n        address: state.address,\n    }))\n}\n\nfunction mapTezosWallet&lt;O&gt;(provider: AbstractConnectionProvider&lt;O, TezosProviderConnectionResult&gt;): ConnectionProvider&lt;O, WalletAndAddress&gt; {\n    return provider.map(async state =&gt; {\n      const {\n        beacon_provider: createBeaconProvider\n      } = await import(\"@rarible/tezos-sdk/dist/providers/beacon/beacon_provider\")\n      const provider = await createBeaconProvider(state.wallet as any, state.toolkit)\n\n      return {\n            wallet: new TezosWallet(provider),\n            address: state.address,\n        }\n    })\n}\n\nconst injected = mapEthereumWallet(new InjectedWeb3ConnectionProvider())\n\nconst mew = mapEthereumWallet(new MEWConnectionProvider({\n    networkId: 4,\n    rpcUrl: ethereumRpcMap[4]\n}))\n\nconst beacon = mapTezosWallet(new BeaconConnectionProvider({\n    appName: \"Rarible Test\",\n    accessNode: \"https://tezos-hangzhou-node.rarible.org\",\n    network: TezosNetwork.HANGZHOUNET\n}))\n\nconst fcl = mapFlowWallet(new FclConnectionProvider({\n    accessNode: \"https://access-testnet.onflow.org\",\n    walletDiscovery: \"https://flow-wallet-testnet.blocto.app/authn\",\n    network: \"testnet\",\n    applicationTitle: \"Rari Test\",\n    applicationIcon: \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\"\n}))\n\nconst torus = mapEthereumWallet(new TorusConnectionProvider({\n    network: {\n        host: \"rinkeby\"\n    }\n}))\n\nconst walletLink = mapEthereumWallet(new WalletLinkConnectionProvider({\n    estimationUrl: ethereumRpcMap[4],\n    networkId: 4,\n    url: ethereumRpcMap[4]\n}, {\n    appName: \"Rarible\",\n    appLogoUrl: \"https://rarible.com/static/logo-500.static.png\",\n    darkMode: false\n}))\n\nconst walletConnect = mapEthereumWallet(new WalletConnectConnectionProvider({\n    rpc: {\n        4: \"https://node-rinkeby.rarible.com\"\n    },\n    chainId: 4\n}))\n\n// Providers required secrets\n// const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } }))\n// const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" }))\n\nconst state: IConnectorStateProvider = {\n    async getValue(): Promise&lt;string | undefined&gt; {\n        const value = localStorage.getItem(\"saved_provider\")\n        return value ? value : undefined\n    },\n    async setValue(value: string | undefined): Promise&lt;void&gt; {\n        localStorage.setItem(\"saved_provider\", value || \"\")\n    },\n}\n\nconst connector = Connector\n    .create(injected, state) // use ConnectionState for store connector data (last connected provider, etc)\n    .add(torus)\n    .add(walletLink)\n    .add(mew)\n    .add(beacon)\n    .add(fcl)\n    .add(walletConnect)\n    // .add(portis)\n    // .add(fortmatic)\n\n\nconnector.connection.subscribe((con) =&gt; {\n    console.log(\"connection: \" + JSON.stringify(con))\n    if (con.status === \"connected\") {\n        const sdk = createRaribleSdk(con.connection.wallet, \"staging\")\n        // use sdk here\n    }\n})\n\nconst options = await connector.getOptions()\nawait connector.connect(options[0])\n</code></pre>"},{"location":"reference/wallets/#available-providers","title":"Available providers","text":"<p>Ethereum providers:</p> <pre><code>InjectedWeb3ConnectionProvider - metamask, coinbase, etc\nFortmaticConnectionProvider\nPortisConnectionProvider\nTorusConnectionProvider\nWalletLinkConnectionProvider\nMEWConnectionProvider\nIframeConnectionProvider\nWalletConnectConnectionProvider\n</code></pre> <p>Tezos providers:</p> <pre><code>BeaconConnectionProvider\n</code></pre> <p>Flow providers:</p> <pre><code>FclConnectionProvider\n</code></pre> <p>Read more about installation and using examples of Rarible SDK Wallet Connector.</p>"},{"location":"snippets/WalletConnectorReadme/","title":"WalletConnectorReadme","text":""},{"location":"snippets/WalletConnectorReadme/#install","title":"Install","text":"<p>Yarn <pre><code>    yarn add @rarible/connector\n    # optional: add additional connectors\n    yarn add @rarible/connector-walletconnect\n    yarn add @rarible/connector-fortmatic\n    # check other @rarible/connector-* packages to see what's supported \n</code></pre></p> <p>NPM <pre><code>    npm i @rarible/connector\n    # optional: add additional connectors\n    npm i @rarible/connector-walletconnect\n    npm i @rarible/connector-fortmatic\n    # check other @rarible/connector-* packages to see what's supported \n</code></pre></p>"},{"location":"snippets/WalletConnectorReadme/#usage","title":"Usage","text":"<p>Create <code>Connector</code>, add all needed <code>ConnectionProvider's</code></p> <pre><code>import { Connector, InjectedWeb3ConnectionProvider, DappType } from \"@rarible/connector\"\nimport { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\"\n\n// create providers with the required options\nconst injected = new InjectedWeb3ConnectionProvider()\nconst walletConnect = new WalletConnectConnectionProvider()\n\n// create connector and push providers to it \nconst connector = Connector\n    .create([injected, walletConnect])\n\n// subscribe to connection status\nconnector.connection.subscribe((con) =&gt;\n    console.log(\"connection: \" + JSON.stringify(con))\n)\n\nconst options = await connector.getOptions(); // get list of available option\nawait connector.connect(options[0]); // connect to selected provider\n</code></pre>"},{"location":"snippets/WalletConnectorReadme/#usage-with-rarible-sdk","title":"Usage with Rarible SDK","text":"<pre><code>import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\"\nimport Web3 from \"web3\"\nimport { BlockchainWallet, FlowWallet, TezosWallet, EthereumWallet } from \"@rarible/sdk-wallet\"\nimport { Web3Ethereum } from \"@rarible/web3-ethereum\"\nimport {\n    Connector,\n    IConnectorStateProvider,\n    ConnectionProvider,\n    InjectedWeb3ConnectionProvider,\n    AbstractConnectionProvider,\n    EthereumProviderConnectionResult,\n} from \"@rarible/connector\"\nimport { FclConnectionProvider, FlowProviderConnectionResult } from \"@rarible/connector-fcl\"\nimport { MEWConnectionProvider } from \"@rarible/connector-mew\"\nimport { BeaconConnectionProvider, TezosProviderConnectionResult } from \"@rarible/connector-beacon\"\nimport { TorusConnectionProvider } from \"@rarible/connector-torus\"\nimport { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\"\nimport { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\"\nimport { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\"\nimport { PortisConnectionProvider } from \"@rarible/connector-portis\"\n\n\nconst ethereumRpcMap: Record&lt;number, string&gt; = {\n    1: \"https://node-mainnet.rarible.com\",\n    3: \"https://node-ropsten.rarible.com\",\n    4: \"https://node-rinkeby.rarible.com\",\n    17: \"https://node-e2e.rarible.com\",\n}\n\nexport type WalletAndAddress = {\n    wallet: BlockchainWallet\n    address: string\n}\n\nfunction mapEthereumWallet&lt;O&gt;(provider: AbstractConnectionProvider&lt;O, EthereumProviderConnectionResult&gt;): ConnectionProvider&lt;O, WalletAndAddress&gt; {\n    return provider.map(state =&gt; ({\n        wallet: new EthereumWallet(new Web3Ethereum({ web3: new Web3(state.provider), from: state.address })),\n        address: state.address\n    }))\n}\n\nfunction mapFlowWallet&lt;O&gt;(provider: AbstractConnectionProvider&lt;O, FlowProviderConnectionResult&gt;): ConnectionProvider&lt;O, WalletAndAddress&gt; {\n    return provider.map(state =&gt; ({\n        wallet: new FlowWallet(state.fcl),\n        address: state.address,\n    }))\n}\n\nfunction mapTezosWallet&lt;O&gt;(provider: AbstractConnectionProvider&lt;O, TezosProviderConnectionResult&gt;): ConnectionProvider&lt;O, WalletAndAddress&gt; {\n    return provider.map(async state =&gt; {\n      const {\n        beacon_provider: createBeaconProvider\n      } = await import(\"@rarible/tezos-sdk/dist/providers/beacon/beacon_provider\")\n      const provider = await createBeaconProvider(state.wallet as any, state.toolkit)\n\n      return {\n            wallet: new TezosWallet(provider),\n            address: state.address,\n        }\n    })\n}\n\nconst injected = mapEthereumWallet(new InjectedWeb3ConnectionProvider())\n\nconst mew = mapEthereumWallet(new MEWConnectionProvider({\n    networkId: 4,\n    rpcUrl: ethereumRpcMap[4]\n}))\n\nconst beacon = mapTezosWallet(new BeaconConnectionProvider({\n    appName: \"Rarible Test\",\n    accessNode: \"https://tezos-hangzhou-node.rarible.org\",\n    network: TezosNetwork.HANGZHOUNET\n}))\n\nconst fcl = mapFlowWallet(new FclConnectionProvider({\n    accessNode: \"https://access-testnet.onflow.org\",\n    walletDiscovery: \"https://flow-wallet-testnet.blocto.app/authn\",\n    network: \"testnet\",\n    applicationTitle: \"Rari Test\",\n    applicationIcon: \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\"\n}))\n\nconst torus = mapEthereumWallet(new TorusConnectionProvider({\n    network: {\n        host: \"rinkeby\"\n    }\n}))\n\nconst walletLink = mapEthereumWallet(new WalletLinkConnectionProvider({\n    estimationUrl: ethereumRpcMap[4],\n    networkId: 4,\n    url: ethereumRpcMap[4]\n}, {\n    appName: \"Rarible\",\n    appLogoUrl: \"https://rarible.com/static/logo-500.static.png\",\n    darkMode: false\n}))\n\nconst walletConnect = mapEthereumWallet(new WalletConnectConnectionProvider({\n    rpc: {\n        4: \"https://node-rinkeby.rarible.com\"\n    },\n    chainId: 4\n}))\n\n// Providers required secrets\n// const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } }))\n// const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" }))\n\nconst state: IConnectorStateProvider = {\n    async getValue(): Promise&lt;string | undefined&gt; {\n        const value = localStorage.getItem(\"saved_provider\")\n        return value ? value : undefined\n    },\n    async setValue(value: string | undefined): Promise&lt;void&gt; {\n        localStorage.setItem(\"saved_provider\", value || \"\")\n    },\n}\n\nconst connector = Connector\n    .create(injected, state) // use ConnectionState for store connector data (last connected provider, etc)\n    .add(torus)\n    .add(walletLink)\n    .add(mew)\n    .add(beacon)\n    .add(fcl)\n    .add(walletConnect)\n    // .add(portis)\n    // .add(fortmatic)\n\n\nconnector.connection.subscribe((con) =&gt; {\n    console.log(\"connection: \" + JSON.stringify(con))\n    if (con.status === \"connected\") {\n        const sdk = createRaribleSdk(con.connection.wallet, \"staging\")\n        // use sdk here\n    }\n})\n\nconst options = await connector.getOptions()\nawait connector.connect(options[0])\n</code></pre>"},{"location":"snippets/WalletConnectorReadme/#available-providers","title":"Available providers","text":"<p>Ethereum providers:</p> <pre><code>InjectedWeb3ConnectionProvider - metamask, coinbase, etc\nFortmaticConnectionProvider\nPortisConnectionProvider\nTorusConnectionProvider\nWalletLinkConnectionProvider\nMEWConnectionProvider\nIframeConnectionProvider\nWalletConnectConnectionProvider\n</code></pre> <p>Tezos providers:</p> <pre><code>BeaconConnectionProvider\n</code></pre> <p>Flow providers:</p> <pre><code>FclConnectionProvider\n</code></pre>"},{"location":"snippets/preparation-sdk/","title":"Preparation sdk","text":"<p>Before start, install and configure Rarible SDK and required wallets.</p>"},{"location":"snippets/usage-sdk-ethers/","title":"Usage sdk ethers","text":"<p>// Imports import type Wallet from \"ethereumjs-wallet\" import Web3 from \"web3\" import { ethers } from \"ethers\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { EthersEthereum, EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\"</p> <p>// Code export function createProviders(provider: any, wallet: Wallet) {     const web3 = new Web3(provider)     const ethersWeb3Provider = new ethers.providers.Web3Provider(provider)</p> <pre><code>return {\n    web3,\n    providers: [\n        new Web3Ethereum({ web3 }),\n        new EthersEthereum(new ethers.Wallet(wallet.getPrivateKeyString(), ethersWeb3Provider)),\n        new EthersWeb3ProviderEthereum(ethersWeb3Provider),\n    ],\n}\n</code></pre> <p>}</p> <p>const ethWallet = new EthereumWallet(ethersEthereumProviderInstance) const raribleSdk = createRaribleSdk(ethWallet, \"staging\")</p>"},{"location":"snippets/usage-sdk-on-server/","title":"Usage sdk on server","text":""},{"location":"snippets/usage-sdk-on-server/#using-sdk-on-server-application","title":"Using SDK on server application","text":"<p>The SDK was designed for use on the frontend side. To use the SDK on the server side (backend):</p> <ol> <li> <p>Install packages:</p> <pre><code>yarn add tslib@2.3.1\nyarn add form-data\nyarn add node-fetch\n</code></pre> </li> <li> <p>Add dependencies:</p> <pre><code>global.FormData = require(\"form-data\")\nglobal.window = {\n  fetch: require(\"node-fetch\"),\n  dispatchEvent: () =&gt; {\n  },\n}\nglobal.CustomEvent = function CustomEvent() {\n  return\n}\n</code></pre> </li> <li> <p>Try our example to buy Ethereum NFT item on Rinkeby network.</p> <p>Pass private key, node RPC URL, network ID, item ID for buyout and start:</p> <pre><code>ETH_PRIVATE_KEY=\"0x...\" \\\nETHEREUM_RPC_URL=\"https://rinkeby.infura.io/...\" \\\nETHEREUM_NETWORK_ID=\"4\" \\\nBUYOUT_ITEM_ID=\"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\\nts-node packages/sdk/example/backend/buy.ts\n</code></pre> </li> </ol>"},{"location":"snippets/usage-sdk/","title":"Usage sdk","text":"<p>// Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\"</p> <p>// Code const { ethereum } = window as any const web3 = new Web3(provider) const web3Ethereum = new Web3Ethereum({ web3 }) const ethWallet = new EthereumWallet(web3Ethereum) const raribleSdk = createRaribleSdk(ethWallet, \"staging\")</p>"},{"location":"use-cases/bubblesdk/","title":"Rarible SDK No-Code plugin for Bubble","text":"<p>This plugin has been developed by NovaBloq.</p> <p>You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io</p> <p>You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io.</p> <p>Link to the plugin</p> <p>Link to documentation</p> <p>Demo page with available features</p> <p><code>All examples are open source, you can see how it works from the inside.</code></p>"},{"location":"use-cases/bubblesdk/#sdk-supported-features","title":"SDK supported features:","text":"<ul> <li>ERC721 and ERC1155 supported</li> <li>Mint</li> <li>Lazy Mint (Buyer pays the fee)</li> <li>Custom Royalties</li> <li>Custom Origin Fees</li> <li>Create Order (Sell, Bid)</li> <li>Buy item</li> <li>Accept Bid</li> <li>Transfer an NFT to other wallet</li> <li>Cancel Order</li> <li>Burn</li> <li>Create Collection</li> </ul>"},{"location":"use-cases/bubblesdk/#api-supported-features","title":"API supported features:","text":"<ul> <li>Get Item Metadata</li> <li>Get Item Data</li> <li>Get Orders By Wallet</li> <li>Get Order By Hash</li> <li>Get NFT Ownership</li> <li>Get NFT Order Activities</li> <li>Get Order Activities By Item</li> <li>Get All NFT Items By Owner, Creator, Collection</li> </ul>"},{"location":"use-cases/bubblesdk/#supported-chains","title":"Supported chains:","text":"<ul> <li>Ethereum: Mainnet, Rinkeby, Ropsten</li> <li>Polygon: Mainnet,  Mumbai</li> <li>Tezos: Mainnet/Hangzhounet</li> </ul> <p>For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here.</p> <p>Also, you can join our Web3 NoCode community on Discord where you can get help with the plugin and Bubble overall.</p>"},{"location":"use-cases/bubblesdk/#how-to-use","title":"How to use:","text":""},{"location":"use-cases/bubblesdk/#installation","title":"Installation","text":"<ol> <li>Place the element Rarible SDK on the page</li> <li>Make sure it is visible (not in a popup or a hidden group)</li> <li>Select preferred network from the Environment Dropdown</li> </ol> <p>Ready to go, see examples on how to integrate it in demo pages.</p> <p>We are working on documentation and more demo pages.</p>"},{"location":"use-cases/bubblesdk/#wallet-type","title":"Wallet Type","text":"<p>This dropdown from the plugin element is used for indicating the type of wallet used to connect to your app. (Select the one that the user connected with). The dropdown contains only the wallets that are supported by the plugin.</p>"},{"location":"use-cases/bubblesdk/#how-to-use-tezos","title":"How to use Tezos","text":"<ul> <li>Select Tezos Environment from the dropdown (mainnet or testnet)</li> <li>Select Tezos for Wallet type</li> <li>Use actions Connect/Disconnect Tezos Wallet</li> <li>After connection, an event called \"Tezos wallet Connected\" will be triggered. The plugin will be ready to be used after that.</li> </ul> <p>NFT Marketplaces being built with this plugin:  - one2all</p>"},{"location":"use-cases/coconft/","title":"cocoNFT","text":"<p>TLDR:</p> <p>cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins.</p> <p>cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer.</p> <p>cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs.</p> <p>How cocoNFT would have changed things knowing what they know now:</p> <p>On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process.</p> <p>In regards to the database side cocoNFT advises understanding how you structure your database.</p> <p>Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs.</p> <ol> <li>Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar)</li> <li>Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens</li> <li> <p>Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations</p> Note <p>Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both.</p> </li> <li> <p>Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address.</p> </li> <li>Test some functions like <code>name()</code> or <code>symbol()</code> in your terminal to ensure it's working</li> <li>Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder</li> </ol> <p>API and/or SDK is in the works for cocoNFT.</p>"},{"location":"use-cases/mintgate/","title":"MintGate","text":"<p>TLDR: </p> <p>MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers.</p> <p>The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer</p> <p>We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs.</p> <p>How MintGate would have changed things knowing what they know now:</p> <p>One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. </p> <p>Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable.  </p> <p>Step by step instructions for how MintGate started building on Rarible protocol:</p> <p>Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs.</p> <ol> <li>Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar)</li> <li>Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens</li> <li> <p>Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations</p> Note <p>Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both.</p> </li> <li> <p>Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. </p> </li> <li>Test some functions like <code>name()</code> or <code>symbol()</code> in your terminal to ensure it's working</li> <li>Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder</li> </ol> <p>APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs</p>"},{"location":"use-cases/moralisplugin/","title":"Moralis Rarible Plugin","text":"<p>This plugin has been developed by the Moralis team.</p> <ul> <li>For support, open a github issue</li> <li>Link to the plugin</li> <li>Link to documentation</li> </ul> <p>This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it.</p>"},{"location":"use-cases/moralisplugin/#supported-chains","title":"Supported chains","text":"<p>This plugins works with 2 different blockchains:</p> <ul> <li>Ethereum Mainnet (\u2018eth\u2019)</li> <li>Ethereum Rinkeby (\u2018rinkeby\u2019)</li> </ul>"},{"location":"use-cases/moralisplugin/#supported-tokens","title":"Supported tokens","text":"<ul> <li>ERC721</li> <li>ERC1155</li> </ul>"},{"location":"use-cases/moralisplugin/#sdk","title":"SDK","text":"<p>Import the Moralis SDK in your project.</p> <pre><code>&lt;script src=\"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://npmcdn.com/moralis@latest/dist/moralis.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"use-cases/moralisplugin/#lazy-mint","title":"Lazy mint","text":"<p>You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token.</p> <pre><code>await Moralis.Plugins.rarible.lazyMint({\n  chain: 'rinkeby',\n  userAddress: '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3',\n  tokenType: 'ERC1155',\n  tokenUri: '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp',\n  supply: 100,\n  royaltiesAmount: 5, // 0.05% royalty. Optional\n})\n</code></pre> <p>You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each.</p> <pre><code>await Moralis.Plugins.rarible.lazyMint({\n  chain: 'rinkeby',\n  userAddress: '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3',\n  tokenType: 'ERC1155',\n  tokenUri: '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp',\n  supply: 100,\n  royaltiesAmount: 5, // 0.05% royalty. Optional\n  list: true, // Only if lazy listing\n  listTokenAmount: 3, // Only if lazy listing\n  listTokenValue: 10 ** 18, // Only if lazy listing\n  listAssetClass: 'ETH', // only if lazy listing  || optional\n})\n</code></pre>"},{"location":"use-cases/moralisplugin/#sell-order","title":"Sell order","text":"<p>You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each.</p> <pre><code>await Moralis.Plugins.rarible.createSellOrder({\n  chain: 'rinkeby',\n  userAddress: '0xE78dC206875373B351EEF2D182025bb9a64d67B3',\n  makeTokenId: '104734732573670734795292663651146618103387426131809974624560761860320187646009',\n  makeTokenAddress: '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7',\n  makeAssetClass: 'ERC1155',\n  makeValue: '4',\n  takeAssetClass: 'ETH',\n  takeValue: 10 ** 18,\n});\n</code></pre>"},{"location":"use-cases/moralisplugin/#erc20","title":"ERC20","text":"<p>You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters:</p> <pre><code>takeAssetClass: 'ERC20',\ntakeTokenAddress: '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea', // DAI\n</code></pre> <p>Example:</p> <pre><code>await Moralis.Plugins.rarible.createSellOrder({\n  chain: 'rinkeby',\n  userAddress: '0xE78dC206875373B351EEF2D182025bb9a64d67B3',\n  makeTokenId: '104734732573670734795292663651146618103387426131809974624560761860320187646009',\n  makeTokenAddress: '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7',\n  makeAssetClass: 'ERC1155',\n  makeValue: '4',\n  takeAssetClass: 'ERC20',\n  takeTokenAddress: '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea', // DAI\n  takeValue: 10 ** 18,\n});\n</code></pre>"},{"location":"use-cases/picnic/","title":"Picnic","text":"<p>We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data.</p>"},{"location":"use-cases/picnic/#api-calls","title":"API Calls","text":"<p>The following endpoints can be used:</p> <ul> <li>Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org</li> <li>Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org</li> <li>Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org</li> </ul>"},{"location":"use-cases/picnic/#getting-tokens-by-owner","title":"Getting Tokens by Owner","text":"<p>Paginate through owned tokens</p> <pre><code>import axios from 'axios';\n\n/**\n * Get collector's owned tokens.\n * @param {string} owner - owner address (0x...)\n * @param {object} opts - options\n * @param {string} opts.continuation - Rariable continuation ID\n * @param {integer} opts.size - size of tokens to get (default: 100).\n * @return \n */\nconst fetchOwnedTokens = async (owner, opts = {}) =&gt; {\n  const { continuation, size = 100 } = opts;\n\n  try {\n    const result = await axios.get('https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner', {\n      params: { owner, continuation },\n    });\n    const { data } = result;\n\n    // Paginate results\n    let hist = [];\n    if (data.continuation &amp;&amp; data.items.length === size) {\n      hist = await getOwnedTokens(owner, { ...opts, continuation: data.continuation });\n    }\n\n    // Return full history\n    return [...data.items, ...hist];\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n};\n</code></pre> <p>The <code>byOwner</code> endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information.</p> <p>You can use the <code>getItemMetaById</code> Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token.</p> <pre><code>import axios from 'axios';\n\n/**\n * Get token metadata from token id.\n * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001)\n * @return {object}\n */\nconst fetchTokenMetadata = async id =&gt; {\n  const { data } = await axios.get(`https://api.rarible.com/protocol/v0.1/ethereum/nft/items/${id}/meta`);\n  if (!data?.name) {\n    throw new Error('Invalid NFT data', { id, data });\n  }\n  return data;\n};\n</code></pre> <p>If you have question, please reach out. greg@picnic.show / [@gleuch]</p>"},{"location":"use-cases/use-cases-overview/","title":"Use Cases","text":"Project Website Description OnCyber https://oncyber.io/ Multiverse for creators built using Rarible Protocol Unfold https://unfold.com/ Unfold uses Rarible Protocol\u2019s lazy minting support to make it easy for users on mobile to create NFTs in a matter of minutes Footium https://footium.club/ Web3 Football Management game that allows players to become the owner, manager and scout for their very own football club. CocoNFT https://coconft.com/ Create NFTs from your Instagram posts and get Everytime your NFT resells on cocoNFT or Rarible royalties MintGate https://www.mintgate.io/ MintGate powers NFT-gated events and metaverse tickets, and token rewards on socials and content channels Ledger https://www.ledger.com/ Ledger uses Rarible Protocol to show and manage NFTs from wallet interface ZeroQode https://zeroqode.com/ Creating NFT launchpad using Rarible Protocol and SDK Infura https://infura.io/ Blockchain infrastructure provider that incorporates NFT functionality with Rarible Protocol and SDK Swap.net https://www.swap.net/ NFT aggregator and exchange built on Rarible Protocol NFTBots https://nftbots.ai/ Cool tool to create your own NFT twitter bot. Gets data from Rarible Protocol about newly created NFTs and activities Gem https://www.gem.xyz/ NFT aggregator tool, uses Rarible Protocol to get NFT information like activities, balances, ownerships Picnic https://picnic.show/ Picnic uses Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. Step.app https://step.app/ A metaverse with augmented reality and NFT experience Graflr https://www.graflr.com/ An app to create NFTs from photo for fans before your show is even over. Uses Rarible Protocol for complete NFT lifecycle, including no gas Lazy-Minting Digitalax https://www.digitalax.xyz/ Fasion Metaverse build using Rarible Protocol Liteflow https://liteflow.com/ Whitelabel solution for Web3 NFT marketplaces Bubble.io https://bubble.io/ No-Code plugin for NFT management build on Rarible Protocol Moralis.io https://moralis.io/ Plugin for Moralis.io that enables interaction with Rarible"}]}